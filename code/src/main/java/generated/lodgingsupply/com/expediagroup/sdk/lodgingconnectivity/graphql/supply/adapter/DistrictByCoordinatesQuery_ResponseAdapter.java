//
// AUTO-GENERATED FILE. DO NOT MODIFY.
//
// This class was automatically generated by Apollo GraphQL version '4.0.0'.
//
package com.expediagroup.sdk.lodgingconnectivity.graphql.supply.adapter;

import com.apollographql.apollo.api.Adapter;
import com.apollographql.apollo.api.Adapters;
import com.apollographql.apollo.api.Assertions;
import com.apollographql.apollo.api.CustomScalarAdapters;
import com.apollographql.apollo.api.ListAdapter;
import com.apollographql.apollo.api.ObjectAdapter;
import com.apollographql.apollo.api.json.JsonReader;
import com.apollographql.apollo.api.json.JsonWriter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.DistrictByCoordinatesQuery;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.ExemptionCategory;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.Purpose;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.RegistrationNumberType;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.RegulatoryCategory;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.ExemptionCategory_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.OptionalAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.OptionalAdapters;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.Purpose_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.RegistrationNumberType_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.RegulatoryCategory_ResponseAdapter;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Override;
import java.lang.String;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class DistrictByCoordinatesQuery_ResponseAdapter {
  public enum Data implements Adapter<DistrictByCoordinatesQuery.Data> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("districtByCoordinates");

    @Override
    public DistrictByCoordinatesQuery.Data fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<DistrictByCoordinatesQuery.DistrictByCoordinates> _districtByCoordinates = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _districtByCoordinates = new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.DistrictByCoordinates>(DistrictByCoordinates.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new DistrictByCoordinatesQuery.Data(
        _districtByCoordinates
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        DistrictByCoordinatesQuery.Data value) throws IOException {
      writer.name("districtByCoordinates");
      new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.DistrictByCoordinates>(DistrictByCoordinates.INSTANCE, false)).toJson(writer, customScalarAdapters, value.districtByCoordinates);
    }
  }

  public enum DistrictByCoordinates implements Adapter<DistrictByCoordinatesQuery.DistrictByCoordinates> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("id", "description", "localizedName", "nativeLocale", "referenceUrls", "registrationRequired", "legalPropertyTypes", "requirements");

    @Override
    public DistrictByCoordinatesQuery.DistrictByCoordinates fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      String _id = null;
      Optional<String> _description = null;
      Optional<String> _localizedName = null;
      Optional<String> _nativeLocale = null;
      Optional<List<Optional<String>>> _referenceUrls = null;
      Boolean _registrationRequired = null;
      List<Optional<DistrictByCoordinatesQuery.LegalPropertyType>> _legalPropertyTypes = null;
      Optional<List<Optional<DistrictByCoordinatesQuery.Requirement>>> _requirements = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _id = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _description = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 2: _localizedName = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _nativeLocale = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 4: _referenceUrls = new OptionalAdapter<>(new ListAdapter<>(OptionalAdapters.OptionalStringAdapter)).fromJson(reader, customScalarAdapters); break;
          case 5: _registrationRequired = Adapters.BooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 6: _legalPropertyTypes = new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.LegalPropertyType>(LegalPropertyType.INSTANCE, false))).fromJson(reader, customScalarAdapters); break;
          case 7: _requirements = new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.Requirement>(Requirement.INSTANCE, false)))).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_id, "id");
      Assertions.checkFieldNotMissing(_registrationRequired, "registrationRequired");
      Assertions.checkFieldNotMissing(_legalPropertyTypes, "legalPropertyTypes");

      return new DistrictByCoordinatesQuery.DistrictByCoordinates(
        _id,
        _description,
        _localizedName,
        _nativeLocale,
        _referenceUrls,
        _registrationRequired,
        _legalPropertyTypes,
        _requirements
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        DistrictByCoordinatesQuery.DistrictByCoordinates value) throws IOException {
      writer.name("id");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.id);

      writer.name("description");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.description);

      writer.name("localizedName");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.localizedName);

      writer.name("nativeLocale");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.nativeLocale);

      writer.name("referenceUrls");
      new OptionalAdapter<>(new ListAdapter<>(OptionalAdapters.OptionalStringAdapter)).toJson(writer, customScalarAdapters, value.referenceUrls);

      writer.name("registrationRequired");
      Adapters.BooleanAdapter.toJson(writer, customScalarAdapters, value.registrationRequired);

      writer.name("legalPropertyTypes");
      new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.LegalPropertyType>(LegalPropertyType.INSTANCE, false))).toJson(writer, customScalarAdapters, value.legalPropertyTypes);

      writer.name("requirements");
      new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.Requirement>(Requirement.INSTANCE, false)))).toJson(writer, customScalarAdapters, value.requirements);
    }
  }

  public enum LegalPropertyType implements Adapter<DistrictByCoordinatesQuery.LegalPropertyType> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("subtype", "type");

    @Override
    public DistrictByCoordinatesQuery.LegalPropertyType fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<String> _subtype = null;
      Optional<String> _type = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _subtype = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _type = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new DistrictByCoordinatesQuery.LegalPropertyType(
        _subtype,
        _type
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        DistrictByCoordinatesQuery.LegalPropertyType value) throws IOException {
      writer.name("subtype");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.subtype);

      writer.name("type");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.type);
    }
  }

  public enum Requirement implements Adapter<DistrictByCoordinatesQuery.Requirement> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("regulatoryCategory", "regulatoryCategoryLabel", "isVacationRental", "minStayNights", "additionalDataRequirements", "exemptions", "maxNightCap", "qualifiedPropertyTypes", "registrationNumberRequirements");

    @Override
    public DistrictByCoordinatesQuery.Requirement fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<RegulatoryCategory> _regulatoryCategory = null;
      Optional<String> _regulatoryCategoryLabel = null;
      Optional<Boolean> _isVacationRental = null;
      Integer _minStayNights = null;
      Optional<List<Optional<DistrictByCoordinatesQuery.AdditionalDataRequirement>>> _additionalDataRequirements = null;
      Optional<List<Optional<DistrictByCoordinatesQuery.Exemption>>> _exemptions = null;
      Optional<DistrictByCoordinatesQuery.MaxNightCap> _maxNightCap = null;
      Optional<List<Optional<DistrictByCoordinatesQuery.QualifiedPropertyType>>> _qualifiedPropertyTypes = null;
      Optional<List<DistrictByCoordinatesQuery.RegistrationNumberRequirement>> _registrationNumberRequirements = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _regulatoryCategory = new OptionalAdapter<>(RegulatoryCategory_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 1: _regulatoryCategoryLabel = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 2: _isVacationRental = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _minStayNights = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          case 4: _additionalDataRequirements = new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.AdditionalDataRequirement>(AdditionalDataRequirement.INSTANCE, false)))).fromJson(reader, customScalarAdapters); break;
          case 5: _exemptions = new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.Exemption>(Exemption.INSTANCE, false)))).fromJson(reader, customScalarAdapters); break;
          case 6: _maxNightCap = new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.MaxNightCap>(MaxNightCap.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 7: _qualifiedPropertyTypes = new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.QualifiedPropertyType>(QualifiedPropertyType.INSTANCE, false)))).fromJson(reader, customScalarAdapters); break;
          case 8: _registrationNumberRequirements = new OptionalAdapter<>(new ListAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.RegistrationNumberRequirement>(RegistrationNumberRequirement.INSTANCE, false))).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_minStayNights, "minStayNights");

      return new DistrictByCoordinatesQuery.Requirement(
        _regulatoryCategory,
        _regulatoryCategoryLabel,
        _isVacationRental,
        _minStayNights,
        _additionalDataRequirements,
        _exemptions,
        _maxNightCap,
        _qualifiedPropertyTypes,
        _registrationNumberRequirements
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        DistrictByCoordinatesQuery.Requirement value) throws IOException {
      writer.name("regulatoryCategory");
      new OptionalAdapter<>(RegulatoryCategory_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.regulatoryCategory);

      writer.name("regulatoryCategoryLabel");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.regulatoryCategoryLabel);

      writer.name("isVacationRental");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.isVacationRental);

      writer.name("minStayNights");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.minStayNights);

      writer.name("additionalDataRequirements");
      new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.AdditionalDataRequirement>(AdditionalDataRequirement.INSTANCE, false)))).toJson(writer, customScalarAdapters, value.additionalDataRequirements);

      writer.name("exemptions");
      new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.Exemption>(Exemption.INSTANCE, false)))).toJson(writer, customScalarAdapters, value.exemptions);

      writer.name("maxNightCap");
      new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.MaxNightCap>(MaxNightCap.INSTANCE, false)).toJson(writer, customScalarAdapters, value.maxNightCap);

      writer.name("qualifiedPropertyTypes");
      new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.QualifiedPropertyType>(QualifiedPropertyType.INSTANCE, false)))).toJson(writer, customScalarAdapters, value.qualifiedPropertyTypes);

      writer.name("registrationNumberRequirements");
      new OptionalAdapter<>(new ListAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.RegistrationNumberRequirement>(RegistrationNumberRequirement.INSTANCE, false))).toJson(writer, customScalarAdapters, value.registrationNumberRequirements);
    }
  }

  public enum AdditionalDataRequirement implements Adapter<DistrictByCoordinatesQuery.AdditionalDataRequirement> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("group", "groupLocalized", "isOptional", "key", "keyLocalized", "subtype", "subtypeLocalized", "type", "typeLocalized");

    @Override
    public DistrictByCoordinatesQuery.AdditionalDataRequirement fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<String> _group = null;
      Optional<String> _groupLocalized = null;
      Optional<String> _isOptional = null;
      String _key = null;
      Optional<String> _keyLocalized = null;
      Optional<String> _subtype = null;
      Optional<String> _subtypeLocalized = null;
      Optional<String> _type = null;
      Optional<String> _typeLocalized = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _group = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _groupLocalized = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 2: _isOptional = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _key = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 4: _keyLocalized = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 5: _subtype = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 6: _subtypeLocalized = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 7: _type = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 8: _typeLocalized = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_key, "key");

      return new DistrictByCoordinatesQuery.AdditionalDataRequirement(
        _group,
        _groupLocalized,
        _isOptional,
        _key,
        _keyLocalized,
        _subtype,
        _subtypeLocalized,
        _type,
        _typeLocalized
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        DistrictByCoordinatesQuery.AdditionalDataRequirement value) throws IOException {
      writer.name("group");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.group);

      writer.name("groupLocalized");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.groupLocalized);

      writer.name("isOptional");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.isOptional);

      writer.name("key");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.key);

      writer.name("keyLocalized");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.keyLocalized);

      writer.name("subtype");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.subtype);

      writer.name("subtypeLocalized");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.subtypeLocalized);

      writer.name("type");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.type);

      writer.name("typeLocalized");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.typeLocalized);
    }
  }

  public enum Exemption implements Adapter<DistrictByCoordinatesQuery.Exemption> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("category", "description");

    @Override
    public DistrictByCoordinatesQuery.Exemption fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<ExemptionCategory> _category = null;
      Optional<String> _description = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _category = new OptionalAdapter<>(ExemptionCategory_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 1: _description = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new DistrictByCoordinatesQuery.Exemption(
        _category,
        _description
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        DistrictByCoordinatesQuery.Exemption value) throws IOException {
      writer.name("category");
      new OptionalAdapter<>(ExemptionCategory_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.category);

      writer.name("description");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.description);
    }
  }

  public enum MaxNightCap implements Adapter<DistrictByCoordinatesQuery.MaxNightCap> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("annualLimit", "isEnforced");

    @Override
    public DistrictByCoordinatesQuery.MaxNightCap fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<Integer> _annualLimit = null;
      Optional<Boolean> _isEnforced = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _annualLimit = OptionalAdapters.OptionalIntAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _isEnforced = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new DistrictByCoordinatesQuery.MaxNightCap(
        _annualLimit,
        _isEnforced
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        DistrictByCoordinatesQuery.MaxNightCap value) throws IOException {
      writer.name("annualLimit");
      OptionalAdapters.OptionalIntAdapter.toJson(writer, customScalarAdapters, value.annualLimit);

      writer.name("isEnforced");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.isEnforced);
    }
  }

  public enum QualifiedPropertyType implements Adapter<DistrictByCoordinatesQuery.QualifiedPropertyType> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("subtype", "type");

    @Override
    public DistrictByCoordinatesQuery.QualifiedPropertyType fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<String> _subtype = null;
      Optional<String> _type = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _subtype = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _type = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new DistrictByCoordinatesQuery.QualifiedPropertyType(
        _subtype,
        _type
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        DistrictByCoordinatesQuery.QualifiedPropertyType value) throws IOException {
      writer.name("subtype");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.subtype);

      writer.name("type");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.type);
    }
  }

  public enum RegistrationNumberRequirement implements Adapter<DistrictByCoordinatesQuery.RegistrationNumberRequirement> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("url", "allowPendingRegistrations", "format", "isExpirationDateRequired", "isOptional", "localName", "numberType", "numberTypeLabel", "purpose", "regex", "thirdPartyValidation");

    @Override
    public DistrictByCoordinatesQuery.RegistrationNumberRequirement fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<String> _url = null;
      Boolean _allowPendingRegistrations = null;
      Optional<String> _format = null;
      Boolean _isExpirationDateRequired = null;
      Boolean _isOptional = null;
      Optional<String> _localName = null;
      Optional<RegistrationNumberType> _numberType = null;
      Optional<String> _numberTypeLabel = null;
      Optional<Purpose> _purpose = null;
      Optional<String> _regex = null;
      Optional<DistrictByCoordinatesQuery.ThirdPartyValidation> _thirdPartyValidation = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _url = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _allowPendingRegistrations = Adapters.BooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 2: _format = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _isExpirationDateRequired = Adapters.BooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 4: _isOptional = Adapters.BooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 5: _localName = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 6: _numberType = new OptionalAdapter<>(RegistrationNumberType_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 7: _numberTypeLabel = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 8: _purpose = new OptionalAdapter<>(Purpose_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 9: _regex = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 10: _thirdPartyValidation = new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.ThirdPartyValidation>(ThirdPartyValidation.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_allowPendingRegistrations, "allowPendingRegistrations");
      Assertions.checkFieldNotMissing(_isExpirationDateRequired, "isExpirationDateRequired");
      Assertions.checkFieldNotMissing(_isOptional, "isOptional");

      return new DistrictByCoordinatesQuery.RegistrationNumberRequirement(
        _url,
        _allowPendingRegistrations,
        _format,
        _isExpirationDateRequired,
        _isOptional,
        _localName,
        _numberType,
        _numberTypeLabel,
        _purpose,
        _regex,
        _thirdPartyValidation
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        DistrictByCoordinatesQuery.RegistrationNumberRequirement value) throws IOException {
      writer.name("url");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.url);

      writer.name("allowPendingRegistrations");
      Adapters.BooleanAdapter.toJson(writer, customScalarAdapters, value.allowPendingRegistrations);

      writer.name("format");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.format);

      writer.name("isExpirationDateRequired");
      Adapters.BooleanAdapter.toJson(writer, customScalarAdapters, value.isExpirationDateRequired);

      writer.name("isOptional");
      Adapters.BooleanAdapter.toJson(writer, customScalarAdapters, value.isOptional);

      writer.name("localName");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.localName);

      writer.name("numberType");
      new OptionalAdapter<>(RegistrationNumberType_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.numberType);

      writer.name("numberTypeLabel");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.numberTypeLabel);

      writer.name("purpose");
      new OptionalAdapter<>(Purpose_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.purpose);

      writer.name("regex");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.regex);

      writer.name("thirdPartyValidation");
      new OptionalAdapter<>(new ObjectAdapter<DistrictByCoordinatesQuery.ThirdPartyValidation>(ThirdPartyValidation.INSTANCE, false)).toJson(writer, customScalarAdapters, value.thirdPartyValidation);
    }
  }

  public enum ThirdPartyValidation implements Adapter<DistrictByCoordinatesQuery.ThirdPartyValidation> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("attributes", "required");

    @Override
    public DistrictByCoordinatesQuery.ThirdPartyValidation fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<List<Optional<String>>> _attributes = null;
      Boolean _required = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _attributes = new OptionalAdapter<>(new ListAdapter<>(OptionalAdapters.OptionalStringAdapter)).fromJson(reader, customScalarAdapters); break;
          case 1: _required = Adapters.BooleanAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_required, "required");

      return new DistrictByCoordinatesQuery.ThirdPartyValidation(
        _attributes,
        _required
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        DistrictByCoordinatesQuery.ThirdPartyValidation value) throws IOException {
      writer.name("attributes");
      new OptionalAdapter<>(new ListAdapter<>(OptionalAdapters.OptionalStringAdapter)).toJson(writer, customScalarAdapters, value.attributes);

      writer.name("required");
      Adapters.BooleanAdapter.toJson(writer, customScalarAdapters, value.required);
    }
  }
}
