//
// AUTO-GENERATED FILE. DO NOT MODIFY.
//
// This class was automatically generated by Apollo GraphQL version '4.0.0'.
//
package com.expediagroup.sdk.lodgingconnectivity.graphql.supply.adapter;

import com.apollographql.apollo.api.Adapter;
import com.apollographql.apollo.api.Adapters;
import com.apollographql.apollo.api.Assertions;
import com.apollographql.apollo.api.CustomScalarAdapters;
import com.apollographql.apollo.api.ListAdapter;
import com.apollographql.apollo.api.ObjectAdapter;
import com.apollographql.apollo.api.json.JsonReader;
import com.apollographql.apollo.api.json.JsonWriter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.RatePlanQuery;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.CurrencyCode;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.Decimal;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeAgeCategory;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeBusinessModel;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeChargeDuration;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeChargeType;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.MerchantOfRecord;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.PricingModel;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.RatePlanStatus;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.RatePlanType;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeAgeCategory_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeBusinessModel_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeChargeDuration_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeChargeType_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.MerchantOfRecord_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.OptionalAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.OptionalAdapters;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.PricingModel_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.RatePlanStatus_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.RatePlanType_ResponseAdapter;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Override;
import java.lang.String;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class RatePlanQuery_ResponseAdapter {
  public enum Data implements Adapter<RatePlanQuery.Data> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("ratePlan");

    @Override
    public RatePlanQuery.Data fromJson(JsonReader reader, CustomScalarAdapters customScalarAdapters)
        throws IOException {
      Optional<RatePlanQuery.RatePlan> _ratePlan = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _ratePlan = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.RatePlan>(RatePlan.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new RatePlanQuery.Data(
        _ratePlan
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.Data value) throws IOException {
      writer.name("ratePlan");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.RatePlan>(RatePlan.INSTANCE, false)).toJson(writer, customScalarAdapters, value.ratePlan);
    }
  }

  public enum RatePlan implements Adapter<RatePlanQuery.RatePlan> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("id", "lastUpdateDateTime", "name", "paymentScheduleApplicable", "pricingModel", "propertyId", "status", "taxInclusive", "type", "unitId", "valueAdds", "baseRateGuestCount", "creationDateTime", "distributionRules", "feeSet", "restrictions", "cancellationPolicyConfig");

    @Override
    public RatePlanQuery.RatePlan fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      String _id = null;
      OffsetDateTime _lastUpdateDateTime = null;
      String _name = null;
      Optional<Boolean> _paymentScheduleApplicable = null;
      PricingModel _pricingModel = null;
      String _propertyId = null;
      RatePlanStatus _status = null;
      Optional<Boolean> _taxInclusive = null;
      RatePlanType _type = null;
      String _unitId = null;
      List<String> _valueAdds = null;
      Optional<Integer> _baseRateGuestCount = null;
      OffsetDateTime _creationDateTime = null;
      List<RatePlanQuery.DistributionRule> _distributionRules = null;
      Optional<RatePlanQuery.FeeSet> _feeSet = null;
      RatePlanQuery.Restrictions1 _restrictions = null;
      Optional<RatePlanQuery.CancellationPolicyConfig> _cancellationPolicyConfig = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _id = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _lastUpdateDateTime = com.expediagroup.sdk.lodgingconnectivity.graphql.adapter.DateTimeAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 2: _name = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _paymentScheduleApplicable = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 4: _pricingModel = PricingModel_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 5: _propertyId = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 6: _status = RatePlanStatus_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 7: _taxInclusive = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 8: _type = RatePlanType_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 9: _unitId = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 10: _valueAdds = new ListAdapter<>(Adapters.StringAdapter).fromJson(reader, customScalarAdapters); break;
          case 11: _baseRateGuestCount = OptionalAdapters.OptionalIntAdapter.fromJson(reader, customScalarAdapters); break;
          case 12: _creationDateTime = com.expediagroup.sdk.lodgingconnectivity.graphql.adapter.DateTimeAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 13: _distributionRules = new ListAdapter<>(new ObjectAdapter<RatePlanQuery.DistributionRule>(DistributionRule.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 14: _feeSet = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.FeeSet>(FeeSet.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 15: _restrictions = new ObjectAdapter<RatePlanQuery.Restrictions1>(Restrictions1.INSTANCE, false).fromJson(reader, customScalarAdapters); break;
          case 16: _cancellationPolicyConfig = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.CancellationPolicyConfig>(CancellationPolicyConfig.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_id, "id");
      Assertions.checkFieldNotMissing(_lastUpdateDateTime, "lastUpdateDateTime");
      Assertions.checkFieldNotMissing(_name, "name");
      Assertions.checkFieldNotMissing(_pricingModel, "pricingModel");
      Assertions.checkFieldNotMissing(_propertyId, "propertyId");
      Assertions.checkFieldNotMissing(_status, "status");
      Assertions.checkFieldNotMissing(_type, "type");
      Assertions.checkFieldNotMissing(_unitId, "unitId");
      Assertions.checkFieldNotMissing(_valueAdds, "valueAdds");
      Assertions.checkFieldNotMissing(_creationDateTime, "creationDateTime");
      Assertions.checkFieldNotMissing(_distributionRules, "distributionRules");
      Assertions.checkFieldNotMissing(_restrictions, "restrictions");

      return new RatePlanQuery.RatePlan(
        _id,
        _lastUpdateDateTime,
        _name,
        _paymentScheduleApplicable,
        _pricingModel,
        _propertyId,
        _status,
        _taxInclusive,
        _type,
        _unitId,
        _valueAdds,
        _baseRateGuestCount,
        _creationDateTime,
        _distributionRules,
        _feeSet,
        _restrictions,
        _cancellationPolicyConfig
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.RatePlan value) throws IOException {
      writer.name("id");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.id);

      writer.name("lastUpdateDateTime");
      com.expediagroup.sdk.lodgingconnectivity.graphql.adapter.DateTimeAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.lastUpdateDateTime);

      writer.name("name");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.name);

      writer.name("paymentScheduleApplicable");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.paymentScheduleApplicable);

      writer.name("pricingModel");
      PricingModel_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.pricingModel);

      writer.name("propertyId");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.propertyId);

      writer.name("status");
      RatePlanStatus_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.status);

      writer.name("taxInclusive");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.taxInclusive);

      writer.name("type");
      RatePlanType_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.type);

      writer.name("unitId");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.unitId);

      writer.name("valueAdds");
      new ListAdapter<>(Adapters.StringAdapter).toJson(writer, customScalarAdapters, value.valueAdds);

      writer.name("baseRateGuestCount");
      OptionalAdapters.OptionalIntAdapter.toJson(writer, customScalarAdapters, value.baseRateGuestCount);

      writer.name("creationDateTime");
      com.expediagroup.sdk.lodgingconnectivity.graphql.adapter.DateTimeAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.creationDateTime);

      writer.name("distributionRules");
      new ListAdapter<>(new ObjectAdapter<RatePlanQuery.DistributionRule>(DistributionRule.INSTANCE, false)).toJson(writer, customScalarAdapters, value.distributionRules);

      writer.name("feeSet");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.FeeSet>(FeeSet.INSTANCE, false)).toJson(writer, customScalarAdapters, value.feeSet);

      writer.name("restrictions");
      new ObjectAdapter<RatePlanQuery.Restrictions1>(Restrictions1.INSTANCE, false).toJson(writer, customScalarAdapters, value.restrictions);

      writer.name("cancellationPolicyConfig");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.CancellationPolicyConfig>(CancellationPolicyConfig.INSTANCE, false)).toJson(writer, customScalarAdapters, value.cancellationPolicyConfig);
    }
  }

  public enum DistributionRule implements Adapter<RatePlanQuery.DistributionRule> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("merchantOfRecord", "ratePlanCode");

    @Override
    public RatePlanQuery.DistributionRule fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      MerchantOfRecord _merchantOfRecord = null;
      String _ratePlanCode = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _merchantOfRecord = MerchantOfRecord_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 1: _ratePlanCode = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_merchantOfRecord, "merchantOfRecord");
      Assertions.checkFieldNotMissing(_ratePlanCode, "ratePlanCode");

      return new RatePlanQuery.DistributionRule(
        _merchantOfRecord,
        _ratePlanCode
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.DistributionRule value) throws IOException {
      writer.name("merchantOfRecord");
      MerchantOfRecord_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.merchantOfRecord);

      writer.name("ratePlanCode");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.ratePlanCode);
    }
  }

  public enum FeeSet implements Adapter<RatePlanQuery.FeeSet> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("id", "name", "businessModel", "fees");

    @Override
    public RatePlanQuery.FeeSet fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      String _id = null;
      String _name = null;
      FeeBusinessModel _businessModel = null;
      List<RatePlanQuery.Fee> _fees = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _id = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _name = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 2: _businessModel = FeeBusinessModel_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 3: _fees = new ListAdapter<>(new ObjectAdapter<RatePlanQuery.Fee>(Fee.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_id, "id");
      Assertions.checkFieldNotMissing(_name, "name");
      Assertions.checkFieldNotMissing(_businessModel, "businessModel");
      Assertions.checkFieldNotMissing(_fees, "fees");

      return new RatePlanQuery.FeeSet(
        _id,
        _name,
        _businessModel,
        _fees
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.FeeSet value) throws IOException {
      writer.name("id");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.id);

      writer.name("name");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.name);

      writer.name("businessModel");
      FeeBusinessModel_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.businessModel);

      writer.name("fees");
      new ListAdapter<>(new ObjectAdapter<RatePlanQuery.Fee>(Fee.INSTANCE, false)).toJson(writer, customScalarAdapters, value.fees);
    }
  }

  public enum Fee implements Adapter<RatePlanQuery.Fee> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("name", "scope", "taxable", "type", "variesByLengthOfStay", "ageCategory", "charges", "restrictions");

    @Override
    public RatePlanQuery.Fee fromJson(JsonReader reader, CustomScalarAdapters customScalarAdapters)
        throws IOException {
      String _name = null;
      String _scope = null;
      Optional<Boolean> _taxable = null;
      String _type = null;
      Optional<Boolean> _variesByLengthOfStay = null;
      Optional<FeeAgeCategory> _ageCategory = null;
      List<RatePlanQuery.Charge> _charges = null;
      Optional<RatePlanQuery.Restrictions> _restrictions = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _name = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _scope = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 2: _taxable = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _type = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 4: _variesByLengthOfStay = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 5: _ageCategory = new OptionalAdapter<>(FeeAgeCategory_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 6: _charges = new ListAdapter<>(new ObjectAdapter<RatePlanQuery.Charge>(Charge.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 7: _restrictions = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.Restrictions>(Restrictions.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_name, "name");
      Assertions.checkFieldNotMissing(_scope, "scope");
      Assertions.checkFieldNotMissing(_type, "type");
      Assertions.checkFieldNotMissing(_charges, "charges");

      return new RatePlanQuery.Fee(
        _name,
        _scope,
        _taxable,
        _type,
        _variesByLengthOfStay,
        _ageCategory,
        _charges,
        _restrictions
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.Fee value) throws IOException {
      writer.name("name");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.name);

      writer.name("scope");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.scope);

      writer.name("taxable");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.taxable);

      writer.name("type");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.type);

      writer.name("variesByLengthOfStay");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.variesByLengthOfStay);

      writer.name("ageCategory");
      new OptionalAdapter<>(FeeAgeCategory_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.ageCategory);

      writer.name("charges");
      new ListAdapter<>(new ObjectAdapter<RatePlanQuery.Charge>(Charge.INSTANCE, false)).toJson(writer, customScalarAdapters, value.charges);

      writer.name("restrictions");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.Restrictions>(Restrictions.INSTANCE, false)).toJson(writer, customScalarAdapters, value.restrictions);
    }
  }

  public enum Charge implements Adapter<RatePlanQuery.Charge> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("duration", "flatAmount", "percentage", "type");

    @Override
    public RatePlanQuery.Charge fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      FeeChargeDuration _duration = null;
      Optional<RatePlanQuery.FlatAmount> _flatAmount = null;
      Optional<String> _percentage = null;
      FeeChargeType _type = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _duration = FeeChargeDuration_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 1: _flatAmount = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.FlatAmount>(FlatAmount.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _percentage = new OptionalAdapter<>((customScalarAdapters.<String>responseAdapterFor(Decimal.type))).fromJson(reader, customScalarAdapters); break;
          case 3: _type = FeeChargeType_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_duration, "duration");
      Assertions.checkFieldNotMissing(_type, "type");

      return new RatePlanQuery.Charge(
        _duration,
        _flatAmount,
        _percentage,
        _type
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.Charge value) throws IOException {
      writer.name("duration");
      FeeChargeDuration_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.duration);

      writer.name("flatAmount");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.FlatAmount>(FlatAmount.INSTANCE, false)).toJson(writer, customScalarAdapters, value.flatAmount);

      writer.name("percentage");
      new OptionalAdapter<>((customScalarAdapters.<String>responseAdapterFor(Decimal.type))).toJson(writer, customScalarAdapters, value.percentage);

      writer.name("type");
      FeeChargeType_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.type);
    }
  }

  public enum FlatAmount implements Adapter<RatePlanQuery.FlatAmount> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("amount", "currencyCode");

    @Override
    public RatePlanQuery.FlatAmount fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      String _amount = null;
      String _currencyCode = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _amount = (customScalarAdapters.<String>responseAdapterFor(Decimal.type)).fromJson(reader, customScalarAdapters); break;
          case 1: _currencyCode = (customScalarAdapters.<String>responseAdapterFor(CurrencyCode.type)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_amount, "amount");
      Assertions.checkFieldNotMissing(_currencyCode, "currencyCode");

      return new RatePlanQuery.FlatAmount(
        _amount,
        _currencyCode
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.FlatAmount value) throws IOException {
      writer.name("amount");
      (customScalarAdapters.<String>responseAdapterFor(Decimal.type)).toJson(writer, customScalarAdapters, value.amount);

      writer.name("currencyCode");
      (customScalarAdapters.<String>responseAdapterFor(CurrencyCode.type)).toJson(writer, customScalarAdapters, value.currencyCode);
    }
  }

  public enum Restrictions implements Adapter<RatePlanQuery.Restrictions> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("dateRange", "extraGuestRange", "rangeOfNight");

    @Override
    public RatePlanQuery.Restrictions fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<RatePlanQuery.DateRange> _dateRange = null;
      Optional<RatePlanQuery.ExtraGuestRange> _extraGuestRange = null;
      Optional<RatePlanQuery.RangeOfNight> _rangeOfNight = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _dateRange = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.DateRange>(DateRange.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 1: _extraGuestRange = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.ExtraGuestRange>(ExtraGuestRange.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _rangeOfNight = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.RangeOfNight>(RangeOfNight.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new RatePlanQuery.Restrictions(
        _dateRange,
        _extraGuestRange,
        _rangeOfNight
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.Restrictions value) throws IOException {
      writer.name("dateRange");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.DateRange>(DateRange.INSTANCE, false)).toJson(writer, customScalarAdapters, value.dateRange);

      writer.name("extraGuestRange");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.ExtraGuestRange>(ExtraGuestRange.INSTANCE, false)).toJson(writer, customScalarAdapters, value.extraGuestRange);

      writer.name("rangeOfNight");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.RangeOfNight>(RangeOfNight.INSTANCE, false)).toJson(writer, customScalarAdapters, value.rangeOfNight);
    }
  }

  public enum DateRange implements Adapter<RatePlanQuery.DateRange> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("from", "to");

    @Override
    public RatePlanQuery.DateRange fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      LocalDate _from = null;
      Optional<LocalDate> _to = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _from = com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 1: _to = new OptionalAdapter<>(com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_from, "from");

      return new RatePlanQuery.DateRange(
        _from,
        _to
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.DateRange value) throws IOException {
      writer.name("from");
      com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.from);

      writer.name("to");
      new OptionalAdapter<>(com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.to);
    }
  }

  public enum ExtraGuestRange implements Adapter<RatePlanQuery.ExtraGuestRange> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("max", "min");

    @Override
    public RatePlanQuery.ExtraGuestRange fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Integer _max = null;
      Integer _min = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _max = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _min = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_max, "max");
      Assertions.checkFieldNotMissing(_min, "min");

      return new RatePlanQuery.ExtraGuestRange(
        _max,
        _min
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.ExtraGuestRange value) throws IOException {
      writer.name("max");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.max);

      writer.name("min");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.min);
    }
  }

  public enum RangeOfNight implements Adapter<RatePlanQuery.RangeOfNight> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("max", "min");

    @Override
    public RatePlanQuery.RangeOfNight fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Integer _max = null;
      Integer _min = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _max = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _min = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_max, "max");
      Assertions.checkFieldNotMissing(_min, "min");

      return new RatePlanQuery.RangeOfNight(
        _max,
        _min
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.RangeOfNight value) throws IOException {
      writer.name("max");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.max);

      writer.name("min");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.min);
    }
  }

  public enum Restrictions1 implements Adapter<RatePlanQuery.Restrictions1> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("advanceBookingDays", "lengthOfStay", "mobileOnly", "reservationDates", "travelDates");

    @Override
    public RatePlanQuery.Restrictions1 fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<RatePlanQuery.AdvanceBookingDays> _advanceBookingDays = null;
      Optional<RatePlanQuery.LengthOfStay> _lengthOfStay = null;
      Optional<Boolean> _mobileOnly = null;
      Optional<RatePlanQuery.ReservationDates> _reservationDates = null;
      Optional<RatePlanQuery.TravelDates> _travelDates = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _advanceBookingDays = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.AdvanceBookingDays>(AdvanceBookingDays.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 1: _lengthOfStay = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.LengthOfStay>(LengthOfStay.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _mobileOnly = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _reservationDates = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.ReservationDates>(ReservationDates.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 4: _travelDates = new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.TravelDates>(TravelDates.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new RatePlanQuery.Restrictions1(
        _advanceBookingDays,
        _lengthOfStay,
        _mobileOnly,
        _reservationDates,
        _travelDates
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.Restrictions1 value) throws IOException {
      writer.name("advanceBookingDays");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.AdvanceBookingDays>(AdvanceBookingDays.INSTANCE, false)).toJson(writer, customScalarAdapters, value.advanceBookingDays);

      writer.name("lengthOfStay");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.LengthOfStay>(LengthOfStay.INSTANCE, false)).toJson(writer, customScalarAdapters, value.lengthOfStay);

      writer.name("mobileOnly");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.mobileOnly);

      writer.name("reservationDates");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.ReservationDates>(ReservationDates.INSTANCE, false)).toJson(writer, customScalarAdapters, value.reservationDates);

      writer.name("travelDates");
      new OptionalAdapter<>(new ObjectAdapter<RatePlanQuery.TravelDates>(TravelDates.INSTANCE, false)).toJson(writer, customScalarAdapters, value.travelDates);
    }
  }

  public enum AdvanceBookingDays implements Adapter<RatePlanQuery.AdvanceBookingDays> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("max", "min");

    @Override
    public RatePlanQuery.AdvanceBookingDays fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Integer _max = null;
      Integer _min = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _max = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _min = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_max, "max");
      Assertions.checkFieldNotMissing(_min, "min");

      return new RatePlanQuery.AdvanceBookingDays(
        _max,
        _min
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.AdvanceBookingDays value) throws IOException {
      writer.name("max");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.max);

      writer.name("min");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.min);
    }
  }

  public enum LengthOfStay implements Adapter<RatePlanQuery.LengthOfStay> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("max", "min");

    @Override
    public RatePlanQuery.LengthOfStay fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Integer _max = null;
      Integer _min = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _max = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _min = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_max, "max");
      Assertions.checkFieldNotMissing(_min, "min");

      return new RatePlanQuery.LengthOfStay(
        _max,
        _min
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.LengthOfStay value) throws IOException {
      writer.name("max");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.max);

      writer.name("min");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.min);
    }
  }

  public enum ReservationDates implements Adapter<RatePlanQuery.ReservationDates> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("from", "to");

    @Override
    public RatePlanQuery.ReservationDates fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      LocalDate _from = null;
      LocalDate _to = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _from = com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 1: _to = com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_from, "from");
      Assertions.checkFieldNotMissing(_to, "to");

      return new RatePlanQuery.ReservationDates(
        _from,
        _to
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.ReservationDates value) throws IOException {
      writer.name("from");
      com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.from);

      writer.name("to");
      com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.to);
    }
  }

  public enum TravelDates implements Adapter<RatePlanQuery.TravelDates> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("from", "to");

    @Override
    public RatePlanQuery.TravelDates fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      LocalDate _from = null;
      LocalDate _to = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _from = com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 1: _to = com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_from, "from");
      Assertions.checkFieldNotMissing(_to, "to");

      return new RatePlanQuery.TravelDates(
        _from,
        _to
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.TravelDates value) throws IOException {
      writer.name("from");
      com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.from);

      writer.name("to");
      com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.to);
    }
  }

  public enum CancellationPolicyConfig implements Adapter<RatePlanQuery.CancellationPolicyConfig> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("id", "name");

    @Override
    public RatePlanQuery.CancellationPolicyConfig fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      String _id = null;
      String _name = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _id = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _name = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_id, "id");
      Assertions.checkFieldNotMissing(_name, "name");

      return new RatePlanQuery.CancellationPolicyConfig(
        _id,
        _name
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        RatePlanQuery.CancellationPolicyConfig value) throws IOException {
      writer.name("id");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.id);

      writer.name("name");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.name);
    }
  }
}
