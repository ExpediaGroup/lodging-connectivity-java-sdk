//
// AUTO-GENERATED FILE. DO NOT MODIFY.
//
// This class was automatically generated by Apollo GraphQL version '4.0.0'.
//
package com.expediagroup.sdk.lodgingconnectivity.graphql.supply.adapter;

import com.apollographql.apollo.api.Adapter;
import com.apollographql.apollo.api.Adapters;
import com.apollographql.apollo.api.Assertions;
import com.apollographql.apollo.api.CustomScalarAdapters;
import com.apollographql.apollo.api.ListAdapter;
import com.apollographql.apollo.api.ObjectAdapter;
import com.apollographql.apollo.api.json.JsonReader;
import com.apollographql.apollo.api.json.JsonWriter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.PropertyFeeSetsQuery;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.CurrencyCode;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.Decimal;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeAgeCategory;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeBusinessModel;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeChargeDuration;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeChargeType;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeAgeCategory_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeBusinessModel_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeChargeDuration_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeChargeType_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.OptionalAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.OptionalAdapters;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Override;
import java.lang.String;
import java.time.LocalDate;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class PropertyFeeSetsQuery_ResponseAdapter {
  public enum Data implements Adapter<PropertyFeeSetsQuery.Data> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("property");

    @Override
    public PropertyFeeSetsQuery.Data fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<PropertyFeeSetsQuery.Property> _property = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _property = new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.Property>(Property.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new PropertyFeeSetsQuery.Data(
        _property
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.Data value) throws IOException {
      writer.name("property");
      new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.Property>(Property.INSTANCE, false)).toJson(writer, customScalarAdapters, value.property);
    }
  }

  public enum Property implements Adapter<PropertyFeeSetsQuery.Property> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("feeSets");

    @Override
    public PropertyFeeSetsQuery.Property fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<PropertyFeeSetsQuery.FeeSets> _feeSets = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _feeSets = new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.FeeSets>(FeeSets.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new PropertyFeeSetsQuery.Property(
        _feeSets
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.Property value) throws IOException {
      writer.name("feeSets");
      new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.FeeSets>(FeeSets.INSTANCE, false)).toJson(writer, customScalarAdapters, value.feeSets);
    }
  }

  public enum FeeSets implements Adapter<PropertyFeeSetsQuery.FeeSets> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("elements", "totalCount");

    @Override
    public PropertyFeeSetsQuery.FeeSets fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      List<PropertyFeeSetsQuery.Element> _elements = null;
      Integer _totalCount = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _elements = new ListAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.Element>(Element.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 1: _totalCount = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_elements, "elements");
      Assertions.checkFieldNotMissing(_totalCount, "totalCount");

      return new PropertyFeeSetsQuery.FeeSets(
        _elements,
        _totalCount
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.FeeSets value) throws IOException {
      writer.name("elements");
      new ListAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.Element>(Element.INSTANCE, false)).toJson(writer, customScalarAdapters, value.elements);

      writer.name("totalCount");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.totalCount);
    }
  }

  public enum Element implements Adapter<PropertyFeeSetsQuery.Element> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("businessModel", "fees", "id", "name");

    @Override
    public PropertyFeeSetsQuery.Element fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      FeeBusinessModel _businessModel = null;
      List<PropertyFeeSetsQuery.Fee> _fees = null;
      String _id = null;
      String _name = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _businessModel = FeeBusinessModel_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 1: _fees = new ListAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.Fee>(Fee.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _id = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _name = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_businessModel, "businessModel");
      Assertions.checkFieldNotMissing(_fees, "fees");
      Assertions.checkFieldNotMissing(_id, "id");
      Assertions.checkFieldNotMissing(_name, "name");

      return new PropertyFeeSetsQuery.Element(
        _businessModel,
        _fees,
        _id,
        _name
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.Element value) throws IOException {
      writer.name("businessModel");
      FeeBusinessModel_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.businessModel);

      writer.name("fees");
      new ListAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.Fee>(Fee.INSTANCE, false)).toJson(writer, customScalarAdapters, value.fees);

      writer.name("id");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.id);

      writer.name("name");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.name);
    }
  }

  public enum Fee implements Adapter<PropertyFeeSetsQuery.Fee> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("ageCategory", "charges", "name", "restrictions", "scope", "taxable", "type", "variesByLengthOfStay");

    @Override
    public PropertyFeeSetsQuery.Fee fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<FeeAgeCategory> _ageCategory = null;
      List<PropertyFeeSetsQuery.Charge> _charges = null;
      String _name = null;
      Optional<PropertyFeeSetsQuery.Restrictions> _restrictions = null;
      String _scope = null;
      Optional<Boolean> _taxable = null;
      String _type = null;
      Optional<Boolean> _variesByLengthOfStay = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _ageCategory = new OptionalAdapter<>(FeeAgeCategory_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 1: _charges = new ListAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.Charge>(Charge.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _name = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _restrictions = new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.Restrictions>(Restrictions.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 4: _scope = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 5: _taxable = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 6: _type = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 7: _variesByLengthOfStay = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_charges, "charges");
      Assertions.checkFieldNotMissing(_name, "name");
      Assertions.checkFieldNotMissing(_scope, "scope");
      Assertions.checkFieldNotMissing(_type, "type");

      return new PropertyFeeSetsQuery.Fee(
        _ageCategory,
        _charges,
        _name,
        _restrictions,
        _scope,
        _taxable,
        _type,
        _variesByLengthOfStay
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.Fee value) throws IOException {
      writer.name("ageCategory");
      new OptionalAdapter<>(FeeAgeCategory_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.ageCategory);

      writer.name("charges");
      new ListAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.Charge>(Charge.INSTANCE, false)).toJson(writer, customScalarAdapters, value.charges);

      writer.name("name");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.name);

      writer.name("restrictions");
      new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.Restrictions>(Restrictions.INSTANCE, false)).toJson(writer, customScalarAdapters, value.restrictions);

      writer.name("scope");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.scope);

      writer.name("taxable");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.taxable);

      writer.name("type");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.type);

      writer.name("variesByLengthOfStay");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.variesByLengthOfStay);
    }
  }

  public enum Charge implements Adapter<PropertyFeeSetsQuery.Charge> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("duration", "flatAmount", "percentage", "type");

    @Override
    public PropertyFeeSetsQuery.Charge fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      FeeChargeDuration _duration = null;
      Optional<PropertyFeeSetsQuery.FlatAmount> _flatAmount = null;
      Optional<String> _percentage = null;
      FeeChargeType _type = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _duration = FeeChargeDuration_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 1: _flatAmount = new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.FlatAmount>(FlatAmount.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _percentage = new OptionalAdapter<>((customScalarAdapters.<String>responseAdapterFor(Decimal.type))).fromJson(reader, customScalarAdapters); break;
          case 3: _type = FeeChargeType_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_duration, "duration");
      Assertions.checkFieldNotMissing(_type, "type");

      return new PropertyFeeSetsQuery.Charge(
        _duration,
        _flatAmount,
        _percentage,
        _type
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.Charge value) throws IOException {
      writer.name("duration");
      FeeChargeDuration_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.duration);

      writer.name("flatAmount");
      new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.FlatAmount>(FlatAmount.INSTANCE, false)).toJson(writer, customScalarAdapters, value.flatAmount);

      writer.name("percentage");
      new OptionalAdapter<>((customScalarAdapters.<String>responseAdapterFor(Decimal.type))).toJson(writer, customScalarAdapters, value.percentage);

      writer.name("type");
      FeeChargeType_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.type);
    }
  }

  public enum FlatAmount implements Adapter<PropertyFeeSetsQuery.FlatAmount> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("amount", "currencyCode");

    @Override
    public PropertyFeeSetsQuery.FlatAmount fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      String _amount = null;
      String _currencyCode = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _amount = (customScalarAdapters.<String>responseAdapterFor(Decimal.type)).fromJson(reader, customScalarAdapters); break;
          case 1: _currencyCode = (customScalarAdapters.<String>responseAdapterFor(CurrencyCode.type)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_amount, "amount");
      Assertions.checkFieldNotMissing(_currencyCode, "currencyCode");

      return new PropertyFeeSetsQuery.FlatAmount(
        _amount,
        _currencyCode
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.FlatAmount value) throws IOException {
      writer.name("amount");
      (customScalarAdapters.<String>responseAdapterFor(Decimal.type)).toJson(writer, customScalarAdapters, value.amount);

      writer.name("currencyCode");
      (customScalarAdapters.<String>responseAdapterFor(CurrencyCode.type)).toJson(writer, customScalarAdapters, value.currencyCode);
    }
  }

  public enum Restrictions implements Adapter<PropertyFeeSetsQuery.Restrictions> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("dateRange", "extraGuestRange", "rangeOfNight");

    @Override
    public PropertyFeeSetsQuery.Restrictions fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<PropertyFeeSetsQuery.DateRange> _dateRange = null;
      Optional<PropertyFeeSetsQuery.ExtraGuestRange> _extraGuestRange = null;
      Optional<PropertyFeeSetsQuery.RangeOfNight> _rangeOfNight = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _dateRange = new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.DateRange>(DateRange.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 1: _extraGuestRange = new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.ExtraGuestRange>(ExtraGuestRange.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _rangeOfNight = new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.RangeOfNight>(RangeOfNight.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new PropertyFeeSetsQuery.Restrictions(
        _dateRange,
        _extraGuestRange,
        _rangeOfNight
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.Restrictions value) throws IOException {
      writer.name("dateRange");
      new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.DateRange>(DateRange.INSTANCE, false)).toJson(writer, customScalarAdapters, value.dateRange);

      writer.name("extraGuestRange");
      new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.ExtraGuestRange>(ExtraGuestRange.INSTANCE, false)).toJson(writer, customScalarAdapters, value.extraGuestRange);

      writer.name("rangeOfNight");
      new OptionalAdapter<>(new ObjectAdapter<PropertyFeeSetsQuery.RangeOfNight>(RangeOfNight.INSTANCE, false)).toJson(writer, customScalarAdapters, value.rangeOfNight);
    }
  }

  public enum DateRange implements Adapter<PropertyFeeSetsQuery.DateRange> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("from", "to");

    @Override
    public PropertyFeeSetsQuery.DateRange fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      LocalDate _from = null;
      Optional<LocalDate> _to = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _from = com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 1: _to = new OptionalAdapter<>(com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_from, "from");

      return new PropertyFeeSetsQuery.DateRange(
        _from,
        _to
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.DateRange value) throws IOException {
      writer.name("from");
      com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.from);

      writer.name("to");
      new OptionalAdapter<>(com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.to);
    }
  }

  public enum ExtraGuestRange implements Adapter<PropertyFeeSetsQuery.ExtraGuestRange> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("max", "min");

    @Override
    public PropertyFeeSetsQuery.ExtraGuestRange fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Integer _max = null;
      Integer _min = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _max = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _min = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_max, "max");
      Assertions.checkFieldNotMissing(_min, "min");

      return new PropertyFeeSetsQuery.ExtraGuestRange(
        _max,
        _min
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.ExtraGuestRange value) throws IOException {
      writer.name("max");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.max);

      writer.name("min");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.min);
    }
  }

  public enum RangeOfNight implements Adapter<PropertyFeeSetsQuery.RangeOfNight> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("max", "min");

    @Override
    public PropertyFeeSetsQuery.RangeOfNight fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Integer _max = null;
      Integer _min = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _max = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _min = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_max, "max");
      Assertions.checkFieldNotMissing(_min, "min");

      return new PropertyFeeSetsQuery.RangeOfNight(
        _max,
        _min
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyFeeSetsQuery.RangeOfNight value) throws IOException {
      writer.name("max");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.max);

      writer.name("min");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.min);
    }
  }
}
