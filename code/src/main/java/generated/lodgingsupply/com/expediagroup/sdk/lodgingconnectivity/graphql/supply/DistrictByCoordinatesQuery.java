//
// AUTO-GENERATED FILE. DO NOT MODIFY.
//
// This class was automatically generated by Apollo GraphQL version '4.0.0'.
//
package com.expediagroup.sdk.lodgingconnectivity.graphql.supply;

import com.apollographql.apollo.api.Adapter;
import com.apollographql.apollo.api.CompiledField;
import com.apollographql.apollo.api.CustomScalarAdapters;
import com.apollographql.apollo.api.ObjectAdapter;
import com.apollographql.apollo.api.Query;
import com.apollographql.apollo.api.json.JsonWriter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.adapter.DistrictByCoordinatesQuery_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.adapter.DistrictByCoordinatesQuery_VariablesAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.selections.DistrictByCoordinatesQuerySelections;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.ExemptionCategory;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.Purpose;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.RegistrationNumberType;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.RegulatoryCategory;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.util.List;
import java.util.Optional;

public class DistrictByCoordinatesQuery implements Query<DistrictByCoordinatesQuery.Data> {
  public static final String OPERATION_ID = "63d3b6d7b12195c2226160a32dd6930b726459a626d122ca027a0b547e535001";

  /**
   * The minimized GraphQL document being sent to the server to save a few bytes.
   * The un-minimized version is:
   *
   * query DistrictByCoordinates($latitude: Float!, $longitude: Float!, $locale: String) {
   *   districtByCoordinates(latitude: $latitude, longitude: $longitude, locale: $locale) {
   *     id
   *     description
   *     localizedName
   *     nativeLocale
   *     referenceUrls
   *     registrationRequired
   *     legalPropertyTypes {
   *       subtype
   *       type
   *     }
   *     requirements {
   *       regulatoryCategory
   *       regulatoryCategoryLabel
   *       isVacationRental
   *       minStayNights
   *       additionalDataRequirements {
   *         group
   *         groupLocalized
   *         isOptional
   *         key
   *         keyLocalized
   *         subtype
   *         subtypeLocalized
   *         type
   *         typeLocalized
   *       }
   *       exemptions {
   *         category
   *         description
   *       }
   *       maxNightCap {
   *         annualLimit
   *         isEnforced
   *       }
   *       qualifiedPropertyTypes {
   *         subtype
   *         type
   *       }
   *       registrationNumberRequirements {
   *         url
   *         allowPendingRegistrations
   *         format
   *         isExpirationDateRequired
   *         isOptional
   *         localName
   *         numberType
   *         numberTypeLabel
   *         purpose
   *         regex
   *         thirdPartyValidation {
   *           attributes
   *           required
   *         }
   *       }
   *     }
   *   }
   * }
   */
  public static final String OPERATION_DOCUMENT = "query DistrictByCoordinates($latitude: Float!, $longitude: Float!, $locale: String) { districtByCoordinates(latitude: $latitude, longitude: $longitude, locale: $locale) { id description localizedName nativeLocale referenceUrls registrationRequired legalPropertyTypes { subtype type } requirements { regulatoryCategory regulatoryCategoryLabel isVacationRental minStayNights additionalDataRequirements { group groupLocalized isOptional key keyLocalized subtype subtypeLocalized type typeLocalized } exemptions { category description } maxNightCap { annualLimit isEnforced } qualifiedPropertyTypes { subtype type } registrationNumberRequirements { url allowPendingRegistrations format isExpirationDateRequired isOptional localName numberType numberTypeLabel purpose regex thirdPartyValidation { attributes required } } } } }";

  public static final String OPERATION_NAME = "DistrictByCoordinates";

  public final Double latitude;

  public final Double longitude;

  public final Optional<String> locale;

  private transient volatile int $hashCode;

  private transient volatile boolean $hashCodeMemoized;

  private transient volatile String $toString;

  public DistrictByCoordinatesQuery(Double latitude, Double longitude, Optional<String> locale) {
    this.latitude = latitude;
    this.longitude = longitude;
    this.locale = locale;
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof DistrictByCoordinatesQuery) {
      DistrictByCoordinatesQuery that = (DistrictByCoordinatesQuery) o;
      return ((this.latitude == null) ? (that.latitude == null) : this.latitude.equals(that.latitude))
       &&((this.longitude == null) ? (that.longitude == null) : this.longitude.equals(that.longitude))
       &&((this.locale == null) ? (that.locale == null) : this.locale.equals(that.locale));
    }
    return false;
  }

  @Override
  public int hashCode() {
    if (!$hashCodeMemoized) {
      int __h = 1;
      __h *= 1000003;
      __h ^= (latitude == null) ? 0 : latitude.hashCode();
      __h *= 1000003;
      __h ^= (longitude == null) ? 0 : longitude.hashCode();
      __h *= 1000003;
      __h ^= (locale == null) ? 0 : locale.hashCode();
      $hashCode = __h;
      $hashCodeMemoized = true;
    }
    return $hashCode;
  }

  @Override
  public String toString() {
    if ($toString == null) {
      $toString = "DistrictByCoordinatesQuery{"
        + "latitude=" + latitude + ", "
        + "longitude=" + longitude + ", "
        + "locale=" + locale
        + "}";
    }
    return $toString;
  }

  public static Builder builder() {
    return new Builder();
  }

  @Override
  public String id() {
    return OPERATION_ID;
  }

  @Override
  public String document() {
    return OPERATION_DOCUMENT;
  }

  @Override
  public String name() {
    return OPERATION_NAME;
  }

  @Override
  public void serializeVariables(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
      boolean withDefaultValues) throws IOException {
    DistrictByCoordinatesQuery_VariablesAdapter.INSTANCE.serializeVariables(writer, this, customScalarAdapters, withDefaultValues);
  }

  @Override
  public Adapter<Data> adapter() {
    return new ObjectAdapter<Data>(DistrictByCoordinatesQuery_ResponseAdapter.Data.INSTANCE, false);
  }

  @Override
  public CompiledField rootField() {
    return new CompiledField.Builder(
      "data",
      com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.Query.type
    )
    .selections(DistrictByCoordinatesQuerySelections.__root)
    .build();
  }

  public static final class Builder {
    private Double latitude;

    private Double longitude;

    private Optional<String> locale = Optional.empty();

    Builder() {
    }

    public Builder latitude(Double latitude) {
      this.latitude = latitude;
      return this;
    }

    public Builder longitude(Double longitude) {
      this.longitude = longitude;
      return this;
    }

    public Builder locale(String locale) {
      this.locale = Optional.of(locale);
      return this;
    }

    public DistrictByCoordinatesQuery build() {
      return new DistrictByCoordinatesQuery(latitude, longitude, locale);
    }
  }

  public static class Data implements Query.Data {
    /**
     * retrieve District information by latitude/longitude coordinates and optionally locale
     */
    public Optional<DistrictByCoordinates> districtByCoordinates;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public Data(Optional<DistrictByCoordinates> districtByCoordinates) {
      this.districtByCoordinates = districtByCoordinates;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Data) {
        Data that = (Data) o;
        return ((this.districtByCoordinates == null) ? (that.districtByCoordinates == null) : this.districtByCoordinates.equals(that.districtByCoordinates));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (districtByCoordinates == null) ? 0 : districtByCoordinates.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Data{"
          + "districtByCoordinates=" + districtByCoordinates
          + "}";
      }
      return $toString;
    }
  }

  public static class DistrictByCoordinates {
    /**
     * District ID (such as Miami Beach).
     */
    public String id;

    /**
     * Description of the district regulation.
     */
    public Optional<String> description;

    /**
     * Localized district name that can be used for display.
     */
    public Optional<String> localizedName;

    /**
     * Four-character locale code (language and country codes) of property's local district (such as ja-JP for a property in Japan).
     */
    public Optional<String> nativeLocale;

    /**
     * URL to jurisdiction regulation information.
     */
    public Optional<List<Optional<String>>> referenceUrls;

    /**
     * Whether registration is required by the jurisdiction.
     */
    public Boolean registrationRequired;

    /**
     * List of legal property types.
     */
    public List<Optional<LegalPropertyType>> legalPropertyTypes;

    /**
     * Jurisdiction regulations that the partner needs to meet to comply with onboarding.
     */
    public Optional<List<Optional<Requirement>>> requirements;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public DistrictByCoordinates(String id, Optional<String> description,
        Optional<String> localizedName, Optional<String> nativeLocale,
        Optional<List<Optional<String>>> referenceUrls, Boolean registrationRequired,
        List<Optional<LegalPropertyType>> legalPropertyTypes,
        Optional<List<Optional<Requirement>>> requirements) {
      this.id = id;
      this.description = description;
      this.localizedName = localizedName;
      this.nativeLocale = nativeLocale;
      this.referenceUrls = referenceUrls;
      this.registrationRequired = registrationRequired;
      this.legalPropertyTypes = legalPropertyTypes;
      this.requirements = requirements;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof DistrictByCoordinates) {
        DistrictByCoordinates that = (DistrictByCoordinates) o;
        return ((this.id == null) ? (that.id == null) : this.id.equals(that.id))
         &&((this.description == null) ? (that.description == null) : this.description.equals(that.description))
         &&((this.localizedName == null) ? (that.localizedName == null) : this.localizedName.equals(that.localizedName))
         &&((this.nativeLocale == null) ? (that.nativeLocale == null) : this.nativeLocale.equals(that.nativeLocale))
         &&((this.referenceUrls == null) ? (that.referenceUrls == null) : this.referenceUrls.equals(that.referenceUrls))
         &&((this.registrationRequired == null) ? (that.registrationRequired == null) : this.registrationRequired.equals(that.registrationRequired))
         &&((this.legalPropertyTypes == null) ? (that.legalPropertyTypes == null) : this.legalPropertyTypes.equals(that.legalPropertyTypes))
         &&((this.requirements == null) ? (that.requirements == null) : this.requirements.equals(that.requirements));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (id == null) ? 0 : id.hashCode();
        __h *= 1000003;
        __h ^= (description == null) ? 0 : description.hashCode();
        __h *= 1000003;
        __h ^= (localizedName == null) ? 0 : localizedName.hashCode();
        __h *= 1000003;
        __h ^= (nativeLocale == null) ? 0 : nativeLocale.hashCode();
        __h *= 1000003;
        __h ^= (referenceUrls == null) ? 0 : referenceUrls.hashCode();
        __h *= 1000003;
        __h ^= (registrationRequired == null) ? 0 : registrationRequired.hashCode();
        __h *= 1000003;
        __h ^= (legalPropertyTypes == null) ? 0 : legalPropertyTypes.hashCode();
        __h *= 1000003;
        __h ^= (requirements == null) ? 0 : requirements.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "DistrictByCoordinates{"
          + "id=" + id + ", "
          + "description=" + description + ", "
          + "localizedName=" + localizedName + ", "
          + "nativeLocale=" + nativeLocale + ", "
          + "referenceUrls=" + referenceUrls + ", "
          + "registrationRequired=" + registrationRequired + ", "
          + "legalPropertyTypes=" + legalPropertyTypes + ", "
          + "requirements=" + requirements
          + "}";
      }
      return $toString;
    }
  }

  public static class LegalPropertyType {
    /**
     * Legal property subtype, applicable for residences, such as primary home or secondary home.
     */
    public Optional<String> subtype;

    /**
     * Legal property type, such as hotel, bed and breakfast, residence, etc.
     */
    public Optional<String> type;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public LegalPropertyType(Optional<String> subtype, Optional<String> type) {
      this.subtype = subtype;
      this.type = type;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof LegalPropertyType) {
        LegalPropertyType that = (LegalPropertyType) o;
        return ((this.subtype == null) ? (that.subtype == null) : this.subtype.equals(that.subtype))
         &&((this.type == null) ? (that.type == null) : this.type.equals(that.type));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (subtype == null) ? 0 : subtype.hashCode();
        __h *= 1000003;
        __h ^= (type == null) ? 0 : type.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "LegalPropertyType{"
          + "subtype=" + subtype + ", "
          + "type=" + type
          + "}";
      }
      return $toString;
    }
  }

  public static class Requirement {
    /**
     * Property regulatory category where the registration number requirements apply.
     */
    public Optional<RegulatoryCategory> regulatoryCategory;

    /**
     * Localized string of the regulatory category.
     */
    public Optional<String> regulatoryCategoryLabel;

    /**
     * Whether this regulatory category is a vacation rental.
     */
    public Optional<Boolean> isVacationRental;

    /**
     * Minimum number of stay nights for this category (default is 1).
     */
    public Integer minStayNights;

    /**
     * Additional required regulation data by jurisdiction, such as license holder name or property address.
     */
    public Optional<List<Optional<AdditionalDataRequirement>>> additionalDataRequirements;

    /**
     * Exemptions of a requirement under certain conditions.
     */
    public Optional<List<Optional<Exemption>>> exemptions;

    /**
     * Maximum number of nights allowed by the jurisdiction. null means no requirement.
     */
    public Optional<MaxNightCap> maxNightCap;

    /**
     * Regulation requirement that EG supports.
     */
    public Optional<List<Optional<QualifiedPropertyType>>> qualifiedPropertyTypes;

    /**
     * List of registration number requirements.
     */
    public Optional<List<RegistrationNumberRequirement>> registrationNumberRequirements;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public Requirement(Optional<RegulatoryCategory> regulatoryCategory,
        Optional<String> regulatoryCategoryLabel, Optional<Boolean> isVacationRental,
        Integer minStayNights,
        Optional<List<Optional<AdditionalDataRequirement>>> additionalDataRequirements,
        Optional<List<Optional<Exemption>>> exemptions, Optional<MaxNightCap> maxNightCap,
        Optional<List<Optional<QualifiedPropertyType>>> qualifiedPropertyTypes,
        Optional<List<RegistrationNumberRequirement>> registrationNumberRequirements) {
      this.regulatoryCategory = regulatoryCategory;
      this.regulatoryCategoryLabel = regulatoryCategoryLabel;
      this.isVacationRental = isVacationRental;
      this.minStayNights = minStayNights;
      this.additionalDataRequirements = additionalDataRequirements;
      this.exemptions = exemptions;
      this.maxNightCap = maxNightCap;
      this.qualifiedPropertyTypes = qualifiedPropertyTypes;
      this.registrationNumberRequirements = registrationNumberRequirements;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Requirement) {
        Requirement that = (Requirement) o;
        return ((this.regulatoryCategory == null) ? (that.regulatoryCategory == null) : this.regulatoryCategory.equals(that.regulatoryCategory))
         &&((this.regulatoryCategoryLabel == null) ? (that.regulatoryCategoryLabel == null) : this.regulatoryCategoryLabel.equals(that.regulatoryCategoryLabel))
         &&((this.isVacationRental == null) ? (that.isVacationRental == null) : this.isVacationRental.equals(that.isVacationRental))
         &&((this.minStayNights == null) ? (that.minStayNights == null) : this.minStayNights.equals(that.minStayNights))
         &&((this.additionalDataRequirements == null) ? (that.additionalDataRequirements == null) : this.additionalDataRequirements.equals(that.additionalDataRequirements))
         &&((this.exemptions == null) ? (that.exemptions == null) : this.exemptions.equals(that.exemptions))
         &&((this.maxNightCap == null) ? (that.maxNightCap == null) : this.maxNightCap.equals(that.maxNightCap))
         &&((this.qualifiedPropertyTypes == null) ? (that.qualifiedPropertyTypes == null) : this.qualifiedPropertyTypes.equals(that.qualifiedPropertyTypes))
         &&((this.registrationNumberRequirements == null) ? (that.registrationNumberRequirements == null) : this.registrationNumberRequirements.equals(that.registrationNumberRequirements));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (regulatoryCategory == null) ? 0 : regulatoryCategory.hashCode();
        __h *= 1000003;
        __h ^= (regulatoryCategoryLabel == null) ? 0 : regulatoryCategoryLabel.hashCode();
        __h *= 1000003;
        __h ^= (isVacationRental == null) ? 0 : isVacationRental.hashCode();
        __h *= 1000003;
        __h ^= (minStayNights == null) ? 0 : minStayNights.hashCode();
        __h *= 1000003;
        __h ^= (additionalDataRequirements == null) ? 0 : additionalDataRequirements.hashCode();
        __h *= 1000003;
        __h ^= (exemptions == null) ? 0 : exemptions.hashCode();
        __h *= 1000003;
        __h ^= (maxNightCap == null) ? 0 : maxNightCap.hashCode();
        __h *= 1000003;
        __h ^= (qualifiedPropertyTypes == null) ? 0 : qualifiedPropertyTypes.hashCode();
        __h *= 1000003;
        __h ^= (registrationNumberRequirements == null) ? 0 : registrationNumberRequirements.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Requirement{"
          + "regulatoryCategory=" + regulatoryCategory + ", "
          + "regulatoryCategoryLabel=" + regulatoryCategoryLabel + ", "
          + "isVacationRental=" + isVacationRental + ", "
          + "minStayNights=" + minStayNights + ", "
          + "additionalDataRequirements=" + additionalDataRequirements + ", "
          + "exemptions=" + exemptions + ", "
          + "maxNightCap=" + maxNightCap + ", "
          + "qualifiedPropertyTypes=" + qualifiedPropertyTypes + ", "
          + "registrationNumberRequirements=" + registrationNumberRequirements
          + "}";
      }
      return $toString;
    }
  }

  public static class AdditionalDataRequirement {
    /**
     * Grouping to which the field belongs, for UI layout purposes.
     */
    public Optional<String> group;

    /**
     * Description of the group, to be localized.
     */
    public Optional<String> groupLocalized;

    /**
     * Whether the data is optional.
     */
    public Optional<String> isOptional;

    /**
     * Field name for the information to be captured.
     */
    public String key;

    /**
     * Description of the key, to be localized.
     */
    public Optional<String> keyLocalized;

    /**
     * Subtype of data.
     */
    public Optional<String> subtype;

    /**
     * Description of subtype, to be localized.
     */
    public Optional<String> subtypeLocalized;

    /**
     * Type of data.
     */
    public Optional<String> type;

    /**
     * Description of type, to be localized.
     */
    public Optional<String> typeLocalized;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public AdditionalDataRequirement(Optional<String> group, Optional<String> groupLocalized,
        Optional<String> isOptional, String key, Optional<String> keyLocalized,
        Optional<String> subtype, Optional<String> subtypeLocalized, Optional<String> type,
        Optional<String> typeLocalized) {
      this.group = group;
      this.groupLocalized = groupLocalized;
      this.isOptional = isOptional;
      this.key = key;
      this.keyLocalized = keyLocalized;
      this.subtype = subtype;
      this.subtypeLocalized = subtypeLocalized;
      this.type = type;
      this.typeLocalized = typeLocalized;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof AdditionalDataRequirement) {
        AdditionalDataRequirement that = (AdditionalDataRequirement) o;
        return ((this.group == null) ? (that.group == null) : this.group.equals(that.group))
         &&((this.groupLocalized == null) ? (that.groupLocalized == null) : this.groupLocalized.equals(that.groupLocalized))
         &&((this.isOptional == null) ? (that.isOptional == null) : this.isOptional.equals(that.isOptional))
         &&((this.key == null) ? (that.key == null) : this.key.equals(that.key))
         &&((this.keyLocalized == null) ? (that.keyLocalized == null) : this.keyLocalized.equals(that.keyLocalized))
         &&((this.subtype == null) ? (that.subtype == null) : this.subtype.equals(that.subtype))
         &&((this.subtypeLocalized == null) ? (that.subtypeLocalized == null) : this.subtypeLocalized.equals(that.subtypeLocalized))
         &&((this.type == null) ? (that.type == null) : this.type.equals(that.type))
         &&((this.typeLocalized == null) ? (that.typeLocalized == null) : this.typeLocalized.equals(that.typeLocalized));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (group == null) ? 0 : group.hashCode();
        __h *= 1000003;
        __h ^= (groupLocalized == null) ? 0 : groupLocalized.hashCode();
        __h *= 1000003;
        __h ^= (isOptional == null) ? 0 : isOptional.hashCode();
        __h *= 1000003;
        __h ^= (key == null) ? 0 : key.hashCode();
        __h *= 1000003;
        __h ^= (keyLocalized == null) ? 0 : keyLocalized.hashCode();
        __h *= 1000003;
        __h ^= (subtype == null) ? 0 : subtype.hashCode();
        __h *= 1000003;
        __h ^= (subtypeLocalized == null) ? 0 : subtypeLocalized.hashCode();
        __h *= 1000003;
        __h ^= (type == null) ? 0 : type.hashCode();
        __h *= 1000003;
        __h ^= (typeLocalized == null) ? 0 : typeLocalized.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "AdditionalDataRequirement{"
          + "group=" + group + ", "
          + "groupLocalized=" + groupLocalized + ", "
          + "isOptional=" + isOptional + ", "
          + "key=" + key + ", "
          + "keyLocalized=" + keyLocalized + ", "
          + "subtype=" + subtype + ", "
          + "subtypeLocalized=" + subtypeLocalized + ", "
          + "type=" + type + ", "
          + "typeLocalized=" + typeLocalized
          + "}";
      }
      return $toString;
    }
  }

  public static class Exemption {
    /**
     * Exemption type.
     */
    public Optional<ExemptionCategory> category;

    /**
     * Description of the exemption.
     */
    public Optional<String> description;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public Exemption(Optional<ExemptionCategory> category, Optional<String> description) {
      this.category = category;
      this.description = description;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Exemption) {
        Exemption that = (Exemption) o;
        return ((this.category == null) ? (that.category == null) : this.category.equals(that.category))
         &&((this.description == null) ? (that.description == null) : this.description.equals(that.description));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (category == null) ? 0 : category.hashCode();
        __h *= 1000003;
        __h ^= (description == null) ? 0 : description.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Exemption{"
          + "category=" + category + ", "
          + "description=" + description
          + "}";
      }
      return $toString;
    }
  }

  public static class MaxNightCap {
    /**
     * Annual night cap.
     */
    public Optional<Integer> annualLimit;

    /**
     * Whether the cap is enforced (or just educational).
     */
    public Optional<Boolean> isEnforced;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public MaxNightCap(Optional<Integer> annualLimit, Optional<Boolean> isEnforced) {
      this.annualLimit = annualLimit;
      this.isEnforced = isEnforced;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof MaxNightCap) {
        MaxNightCap that = (MaxNightCap) o;
        return ((this.annualLimit == null) ? (that.annualLimit == null) : this.annualLimit.equals(that.annualLimit))
         &&((this.isEnforced == null) ? (that.isEnforced == null) : this.isEnforced.equals(that.isEnforced));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (annualLimit == null) ? 0 : annualLimit.hashCode();
        __h *= 1000003;
        __h ^= (isEnforced == null) ? 0 : isEnforced.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "MaxNightCap{"
          + "annualLimit=" + annualLimit + ", "
          + "isEnforced=" + isEnforced
          + "}";
      }
      return $toString;
    }
  }

  public static class QualifiedPropertyType {
    /**
     * Legal property subtype, applicable for residences, such as primary home or secondary home.
     */
    public Optional<String> subtype;

    /**
     * Legal property type, such as hotel, bed and breakfast, residence, etc.
     */
    public Optional<String> type;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public QualifiedPropertyType(Optional<String> subtype, Optional<String> type) {
      this.subtype = subtype;
      this.type = type;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof QualifiedPropertyType) {
        QualifiedPropertyType that = (QualifiedPropertyType) o;
        return ((this.subtype == null) ? (that.subtype == null) : this.subtype.equals(that.subtype))
         &&((this.type == null) ? (that.type == null) : this.type.equals(that.type));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (subtype == null) ? 0 : subtype.hashCode();
        __h *= 1000003;
        __h ^= (type == null) ? 0 : type.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "QualifiedPropertyType{"
          + "subtype=" + subtype + ", "
          + "type=" + type
          + "}";
      }
      return $toString;
    }
  }

  public static class RegistrationNumberRequirement {
    /**
     * URL of a page that provides information about the number requirement.
     */
    public Optional<String> url;

    /**
     * Whether pending applications are allowed to list.
     */
    public Boolean allowPendingRegistrations;

    /**
     * Sample format string to use as an example for partners.
     */
    public Optional<String> format;

    /**
     * Whether the registration expiration date is required.
     */
    public Boolean isExpirationDateRequired;

    /**
     * Whether the registration number is optional.
     */
    public Boolean isOptional;

    /**
     * Localized display name (such as みんぱく for Japan Minpaku).
     */
    public Optional<String> localName;

    /**
     * Registration number type.
     */
    public Optional<RegistrationNumberType> numberType;

    /**
     * Label of the registration number.
     */
    public Optional<String> numberTypeLabel;

    /**
     * Purpose of this requirement if other besides common regulatory validations.
     */
    public Optional<Purpose> purpose;

    /**
     * Regex used to validate the syntax of the registration number.
     */
    public Optional<String> regex;

    /**
     * Information about external validation parameters, if required for the registration number.
     */
    public Optional<ThirdPartyValidation> thirdPartyValidation;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public RegistrationNumberRequirement(Optional<String> url, Boolean allowPendingRegistrations,
        Optional<String> format, Boolean isExpirationDateRequired, Boolean isOptional,
        Optional<String> localName, Optional<RegistrationNumberType> numberType,
        Optional<String> numberTypeLabel, Optional<Purpose> purpose, Optional<String> regex,
        Optional<ThirdPartyValidation> thirdPartyValidation) {
      this.url = url;
      this.allowPendingRegistrations = allowPendingRegistrations;
      this.format = format;
      this.isExpirationDateRequired = isExpirationDateRequired;
      this.isOptional = isOptional;
      this.localName = localName;
      this.numberType = numberType;
      this.numberTypeLabel = numberTypeLabel;
      this.purpose = purpose;
      this.regex = regex;
      this.thirdPartyValidation = thirdPartyValidation;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof RegistrationNumberRequirement) {
        RegistrationNumberRequirement that = (RegistrationNumberRequirement) o;
        return ((this.url == null) ? (that.url == null) : this.url.equals(that.url))
         &&((this.allowPendingRegistrations == null) ? (that.allowPendingRegistrations == null) : this.allowPendingRegistrations.equals(that.allowPendingRegistrations))
         &&((this.format == null) ? (that.format == null) : this.format.equals(that.format))
         &&((this.isExpirationDateRequired == null) ? (that.isExpirationDateRequired == null) : this.isExpirationDateRequired.equals(that.isExpirationDateRequired))
         &&((this.isOptional == null) ? (that.isOptional == null) : this.isOptional.equals(that.isOptional))
         &&((this.localName == null) ? (that.localName == null) : this.localName.equals(that.localName))
         &&((this.numberType == null) ? (that.numberType == null) : this.numberType.equals(that.numberType))
         &&((this.numberTypeLabel == null) ? (that.numberTypeLabel == null) : this.numberTypeLabel.equals(that.numberTypeLabel))
         &&((this.purpose == null) ? (that.purpose == null) : this.purpose.equals(that.purpose))
         &&((this.regex == null) ? (that.regex == null) : this.regex.equals(that.regex))
         &&((this.thirdPartyValidation == null) ? (that.thirdPartyValidation == null) : this.thirdPartyValidation.equals(that.thirdPartyValidation));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (url == null) ? 0 : url.hashCode();
        __h *= 1000003;
        __h ^= (allowPendingRegistrations == null) ? 0 : allowPendingRegistrations.hashCode();
        __h *= 1000003;
        __h ^= (format == null) ? 0 : format.hashCode();
        __h *= 1000003;
        __h ^= (isExpirationDateRequired == null) ? 0 : isExpirationDateRequired.hashCode();
        __h *= 1000003;
        __h ^= (isOptional == null) ? 0 : isOptional.hashCode();
        __h *= 1000003;
        __h ^= (localName == null) ? 0 : localName.hashCode();
        __h *= 1000003;
        __h ^= (numberType == null) ? 0 : numberType.hashCode();
        __h *= 1000003;
        __h ^= (numberTypeLabel == null) ? 0 : numberTypeLabel.hashCode();
        __h *= 1000003;
        __h ^= (purpose == null) ? 0 : purpose.hashCode();
        __h *= 1000003;
        __h ^= (regex == null) ? 0 : regex.hashCode();
        __h *= 1000003;
        __h ^= (thirdPartyValidation == null) ? 0 : thirdPartyValidation.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "RegistrationNumberRequirement{"
          + "url=" + url + ", "
          + "allowPendingRegistrations=" + allowPendingRegistrations + ", "
          + "format=" + format + ", "
          + "isExpirationDateRequired=" + isExpirationDateRequired + ", "
          + "isOptional=" + isOptional + ", "
          + "localName=" + localName + ", "
          + "numberType=" + numberType + ", "
          + "numberTypeLabel=" + numberTypeLabel + ", "
          + "purpose=" + purpose + ", "
          + "regex=" + regex + ", "
          + "thirdPartyValidation=" + thirdPartyValidation
          + "}";
      }
      return $toString;
    }
  }

  public static class ThirdPartyValidation {
    /**
     * Attributes used to validate the registration number as provided by the third-party.
     */
    public Optional<List<Optional<String>>> attributes;

    /**
     * Whether third-party validation is required.
     */
    public Boolean required;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public ThirdPartyValidation(Optional<List<Optional<String>>> attributes, Boolean required) {
      this.attributes = attributes;
      this.required = required;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof ThirdPartyValidation) {
        ThirdPartyValidation that = (ThirdPartyValidation) o;
        return ((this.attributes == null) ? (that.attributes == null) : this.attributes.equals(that.attributes))
         &&((this.required == null) ? (that.required == null) : this.required.equals(that.required));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (attributes == null) ? 0 : attributes.hashCode();
        __h *= 1000003;
        __h ^= (required == null) ? 0 : required.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "ThirdPartyValidation{"
          + "attributes=" + attributes + ", "
          + "required=" + required
          + "}";
      }
      return $toString;
    }
  }
}
