//
// AUTO-GENERATED FILE. DO NOT MODIFY.
//
// This class was automatically generated by Apollo GraphQL version '4.0.0'.
//
package com.expediagroup.sdk.lodgingconnectivity.graphql.supply.adapter;

import com.apollographql.apollo.api.Adapter;
import com.apollographql.apollo.api.Adapters;
import com.apollographql.apollo.api.Assertions;
import com.apollographql.apollo.api.CustomScalarAdapters;
import com.apollographql.apollo.api.ListAdapter;
import com.apollographql.apollo.api.ObjectAdapter;
import com.apollographql.apollo.api.json.JsonReader;
import com.apollographql.apollo.api.json.JsonWriter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.CreateFeeSetMutation;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.CurrencyCode;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.Decimal;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeAgeCategory;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeBusinessModel;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeChargeDuration;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.FeeChargeType;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeAgeCategory_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeBusinessModel_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeChargeDuration_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.FeeChargeType_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.OptionalAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.OptionalAdapters;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Override;
import java.lang.String;
import java.time.LocalDate;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class CreateFeeSetMutation_ResponseAdapter {
  public enum Data implements Adapter<CreateFeeSetMutation.Data> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("createFeeSet");

    @Override
    public CreateFeeSetMutation.Data fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<CreateFeeSetMutation.CreateFeeSet> _createFeeSet = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _createFeeSet = new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.CreateFeeSet>(CreateFeeSet.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new CreateFeeSetMutation.Data(
        _createFeeSet
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        CreateFeeSetMutation.Data value) throws IOException {
      writer.name("createFeeSet");
      new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.CreateFeeSet>(CreateFeeSet.INSTANCE, false)).toJson(writer, customScalarAdapters, value.createFeeSet);
    }
  }

  public enum CreateFeeSet implements Adapter<CreateFeeSetMutation.CreateFeeSet> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("clientMutationId", "feeSet");

    @Override
    public CreateFeeSetMutation.CreateFeeSet fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<String> _clientMutationId = null;
      CreateFeeSetMutation.FeeSet _feeSet = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _clientMutationId = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _feeSet = new ObjectAdapter<CreateFeeSetMutation.FeeSet>(FeeSet.INSTANCE, false).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_feeSet, "feeSet");

      return new CreateFeeSetMutation.CreateFeeSet(
        _clientMutationId,
        _feeSet
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        CreateFeeSetMutation.CreateFeeSet value) throws IOException {
      writer.name("clientMutationId");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.clientMutationId);

      writer.name("feeSet");
      new ObjectAdapter<CreateFeeSetMutation.FeeSet>(FeeSet.INSTANCE, false).toJson(writer, customScalarAdapters, value.feeSet);
    }
  }

  public enum FeeSet implements Adapter<CreateFeeSetMutation.FeeSet> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("id", "fees", "name", "businessModel");

    @Override
    public CreateFeeSetMutation.FeeSet fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      String _id = null;
      List<CreateFeeSetMutation.Fee> _fees = null;
      String _name = null;
      FeeBusinessModel _businessModel = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _id = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _fees = new ListAdapter<>(new ObjectAdapter<CreateFeeSetMutation.Fee>(Fee.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _name = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _businessModel = FeeBusinessModel_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_id, "id");
      Assertions.checkFieldNotMissing(_fees, "fees");
      Assertions.checkFieldNotMissing(_name, "name");
      Assertions.checkFieldNotMissing(_businessModel, "businessModel");

      return new CreateFeeSetMutation.FeeSet(
        _id,
        _fees,
        _name,
        _businessModel
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        CreateFeeSetMutation.FeeSet value) throws IOException {
      writer.name("id");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.id);

      writer.name("fees");
      new ListAdapter<>(new ObjectAdapter<CreateFeeSetMutation.Fee>(Fee.INSTANCE, false)).toJson(writer, customScalarAdapters, value.fees);

      writer.name("name");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.name);

      writer.name("businessModel");
      FeeBusinessModel_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.businessModel);
    }
  }

  public enum Fee implements Adapter<CreateFeeSetMutation.Fee> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("ageCategory", "charges", "name", "restrictions", "scope", "taxable", "type", "variesByLengthOfStay");

    @Override
    public CreateFeeSetMutation.Fee fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<FeeAgeCategory> _ageCategory = null;
      List<CreateFeeSetMutation.Charge> _charges = null;
      String _name = null;
      Optional<CreateFeeSetMutation.Restrictions> _restrictions = null;
      String _scope = null;
      Optional<Boolean> _taxable = null;
      String _type = null;
      Optional<Boolean> _variesByLengthOfStay = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _ageCategory = new OptionalAdapter<>(FeeAgeCategory_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 1: _charges = new ListAdapter<>(new ObjectAdapter<CreateFeeSetMutation.Charge>(Charge.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _name = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _restrictions = new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.Restrictions>(Restrictions.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 4: _scope = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 5: _taxable = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 6: _type = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 7: _variesByLengthOfStay = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_charges, "charges");
      Assertions.checkFieldNotMissing(_name, "name");
      Assertions.checkFieldNotMissing(_scope, "scope");
      Assertions.checkFieldNotMissing(_type, "type");

      return new CreateFeeSetMutation.Fee(
        _ageCategory,
        _charges,
        _name,
        _restrictions,
        _scope,
        _taxable,
        _type,
        _variesByLengthOfStay
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        CreateFeeSetMutation.Fee value) throws IOException {
      writer.name("ageCategory");
      new OptionalAdapter<>(FeeAgeCategory_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.ageCategory);

      writer.name("charges");
      new ListAdapter<>(new ObjectAdapter<CreateFeeSetMutation.Charge>(Charge.INSTANCE, false)).toJson(writer, customScalarAdapters, value.charges);

      writer.name("name");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.name);

      writer.name("restrictions");
      new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.Restrictions>(Restrictions.INSTANCE, false)).toJson(writer, customScalarAdapters, value.restrictions);

      writer.name("scope");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.scope);

      writer.name("taxable");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.taxable);

      writer.name("type");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.type);

      writer.name("variesByLengthOfStay");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.variesByLengthOfStay);
    }
  }

  public enum Charge implements Adapter<CreateFeeSetMutation.Charge> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("duration", "flatAmount", "percentage", "type");

    @Override
    public CreateFeeSetMutation.Charge fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      FeeChargeDuration _duration = null;
      Optional<CreateFeeSetMutation.FlatAmount> _flatAmount = null;
      Optional<String> _percentage = null;
      FeeChargeType _type = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _duration = FeeChargeDuration_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 1: _flatAmount = new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.FlatAmount>(FlatAmount.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _percentage = new OptionalAdapter<>((customScalarAdapters.<String>responseAdapterFor(Decimal.type))).fromJson(reader, customScalarAdapters); break;
          case 3: _type = FeeChargeType_ResponseAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_duration, "duration");
      Assertions.checkFieldNotMissing(_type, "type");

      return new CreateFeeSetMutation.Charge(
        _duration,
        _flatAmount,
        _percentage,
        _type
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        CreateFeeSetMutation.Charge value) throws IOException {
      writer.name("duration");
      FeeChargeDuration_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.duration);

      writer.name("flatAmount");
      new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.FlatAmount>(FlatAmount.INSTANCE, false)).toJson(writer, customScalarAdapters, value.flatAmount);

      writer.name("percentage");
      new OptionalAdapter<>((customScalarAdapters.<String>responseAdapterFor(Decimal.type))).toJson(writer, customScalarAdapters, value.percentage);

      writer.name("type");
      FeeChargeType_ResponseAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.type);
    }
  }

  public enum FlatAmount implements Adapter<CreateFeeSetMutation.FlatAmount> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("amount", "currencyCode");

    @Override
    public CreateFeeSetMutation.FlatAmount fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      String _amount = null;
      String _currencyCode = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _amount = (customScalarAdapters.<String>responseAdapterFor(Decimal.type)).fromJson(reader, customScalarAdapters); break;
          case 1: _currencyCode = (customScalarAdapters.<String>responseAdapterFor(CurrencyCode.type)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_amount, "amount");
      Assertions.checkFieldNotMissing(_currencyCode, "currencyCode");

      return new CreateFeeSetMutation.FlatAmount(
        _amount,
        _currencyCode
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        CreateFeeSetMutation.FlatAmount value) throws IOException {
      writer.name("amount");
      (customScalarAdapters.<String>responseAdapterFor(Decimal.type)).toJson(writer, customScalarAdapters, value.amount);

      writer.name("currencyCode");
      (customScalarAdapters.<String>responseAdapterFor(CurrencyCode.type)).toJson(writer, customScalarAdapters, value.currencyCode);
    }
  }

  public enum Restrictions implements Adapter<CreateFeeSetMutation.Restrictions> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("dateRange", "extraGuestRange", "rangeOfNight");

    @Override
    public CreateFeeSetMutation.Restrictions fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<CreateFeeSetMutation.DateRange> _dateRange = null;
      Optional<CreateFeeSetMutation.ExtraGuestRange> _extraGuestRange = null;
      Optional<CreateFeeSetMutation.RangeOfNight> _rangeOfNight = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _dateRange = new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.DateRange>(DateRange.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 1: _extraGuestRange = new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.ExtraGuestRange>(ExtraGuestRange.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 2: _rangeOfNight = new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.RangeOfNight>(RangeOfNight.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new CreateFeeSetMutation.Restrictions(
        _dateRange,
        _extraGuestRange,
        _rangeOfNight
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        CreateFeeSetMutation.Restrictions value) throws IOException {
      writer.name("dateRange");
      new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.DateRange>(DateRange.INSTANCE, false)).toJson(writer, customScalarAdapters, value.dateRange);

      writer.name("extraGuestRange");
      new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.ExtraGuestRange>(ExtraGuestRange.INSTANCE, false)).toJson(writer, customScalarAdapters, value.extraGuestRange);

      writer.name("rangeOfNight");
      new OptionalAdapter<>(new ObjectAdapter<CreateFeeSetMutation.RangeOfNight>(RangeOfNight.INSTANCE, false)).toJson(writer, customScalarAdapters, value.rangeOfNight);
    }
  }

  public enum DateRange implements Adapter<CreateFeeSetMutation.DateRange> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("from", "to");

    @Override
    public CreateFeeSetMutation.DateRange fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      LocalDate _from = null;
      Optional<LocalDate> _to = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _from = com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.fromJson(reader, customScalarAdapters); break;
          case 1: _to = new OptionalAdapter<>(com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_from, "from");

      return new CreateFeeSetMutation.DateRange(
        _from,
        _to
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        CreateFeeSetMutation.DateRange value) throws IOException {
      writer.name("from");
      com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE.toJson(writer, customScalarAdapters, value.from);

      writer.name("to");
      new OptionalAdapter<>(com.apollographql.adapter.core.JavaLocalDateAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.to);
    }
  }

  public enum ExtraGuestRange implements Adapter<CreateFeeSetMutation.ExtraGuestRange> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("max", "min");

    @Override
    public CreateFeeSetMutation.ExtraGuestRange fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Integer _max = null;
      Integer _min = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _max = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _min = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_max, "max");
      Assertions.checkFieldNotMissing(_min, "min");

      return new CreateFeeSetMutation.ExtraGuestRange(
        _max,
        _min
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        CreateFeeSetMutation.ExtraGuestRange value) throws IOException {
      writer.name("max");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.max);

      writer.name("min");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.min);
    }
  }

  public enum RangeOfNight implements Adapter<CreateFeeSetMutation.RangeOfNight> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("max", "min");

    @Override
    public CreateFeeSetMutation.RangeOfNight fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Integer _max = null;
      Integer _min = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _max = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _min = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_max, "max");
      Assertions.checkFieldNotMissing(_min, "min");

      return new CreateFeeSetMutation.RangeOfNight(
        _max,
        _min
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        CreateFeeSetMutation.RangeOfNight value) throws IOException {
      writer.name("max");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.max);

      writer.name("min");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.min);
    }
  }
}
