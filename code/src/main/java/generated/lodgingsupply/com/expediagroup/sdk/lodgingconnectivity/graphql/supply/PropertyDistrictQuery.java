//
// AUTO-GENERATED FILE. DO NOT MODIFY.
//
// This class was automatically generated by Apollo GraphQL version '4.0.0'.
//
package com.expediagroup.sdk.lodgingconnectivity.graphql.supply;

import com.apollographql.apollo.api.Adapter;
import com.apollographql.apollo.api.CompiledField;
import com.apollographql.apollo.api.CustomScalarAdapters;
import com.apollographql.apollo.api.ObjectAdapter;
import com.apollographql.apollo.api.Query;
import com.apollographql.apollo.api.json.JsonWriter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.adapter.PropertyDistrictQuery_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.adapter.PropertyDistrictQuery_VariablesAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.selections.PropertyDistrictQuerySelections;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.ExemptionCategory;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.Purpose;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.RegistrationNumberType;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.RegulatoryCategory;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.util.List;
import java.util.Optional;

public class PropertyDistrictQuery implements Query<PropertyDistrictQuery.Data> {
  public static final String OPERATION_ID = "e55d9bd36c6f363c571dab87c9a1c5d967a432f9e74fce28a6f75a5caf72050b";

  /**
   * The minimized GraphQL document being sent to the server to save a few bytes.
   * The un-minimized version is:
   *
   * query PropertyDistrict($propertyId: String!, $locale: String) {
   *   property(id: $propertyId) {
   *     district(locale: $locale) {
   *       description
   *       id
   *       legalPropertyTypes {
   *         subtype
   *         type
   *       }
   *       localizedName
   *       nativeLocale
   *       referenceUrls
   *       registrationRequired
   *       requirements {
   *         additionalDataRequirements {
   *           group
   *           groupLocalized
   *           isOptional
   *           key
   *           keyLocalized
   *           subtype
   *           subtypeLocalized
   *           type
   *           typeLocalized
   *         }
   *         exemptions {
   *           category
   *           description
   *         }
   *         isVacationRental
   *         maxNightCap {
   *           annualLimit
   *           isEnforced
   *         }
   *         minStayNights
   *         qualifiedPropertyTypes {
   *           subtype
   *           type
   *         }
   *         registrationNumberRequirements {
   *           allowPendingRegistrations
   *           format
   *           isExpirationDateRequired
   *           isOptional
   *           localName
   *           numberType
   *           numberTypeLabel
   *           purpose
   *           regex
   *           thirdPartyValidation {
   *             attributes
   *             required
   *           }
   *           url
   *         }
   *         regulatoryCategory
   *         regulatoryCategoryLabel
   *       }
   *     }
   *   }
   * }
   */
  public static final String OPERATION_DOCUMENT = "query PropertyDistrict($propertyId: String!, $locale: String) { property(id: $propertyId) { district(locale: $locale) { description id legalPropertyTypes { subtype type } localizedName nativeLocale referenceUrls registrationRequired requirements { additionalDataRequirements { group groupLocalized isOptional key keyLocalized subtype subtypeLocalized type typeLocalized } exemptions { category description } isVacationRental maxNightCap { annualLimit isEnforced } minStayNights qualifiedPropertyTypes { subtype type } registrationNumberRequirements { allowPendingRegistrations format isExpirationDateRequired isOptional localName numberType numberTypeLabel purpose regex thirdPartyValidation { attributes required } url } regulatoryCategory regulatoryCategoryLabel } } } }";

  public static final String OPERATION_NAME = "PropertyDistrict";

  public final String propertyId;

  public final Optional<String> locale;

  private transient volatile int $hashCode;

  private transient volatile boolean $hashCodeMemoized;

  private transient volatile String $toString;

  public PropertyDistrictQuery(String propertyId, Optional<String> locale) {
    this.propertyId = propertyId;
    this.locale = locale;
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (o instanceof PropertyDistrictQuery) {
      PropertyDistrictQuery that = (PropertyDistrictQuery) o;
      return ((this.propertyId == null) ? (that.propertyId == null) : this.propertyId.equals(that.propertyId))
       &&((this.locale == null) ? (that.locale == null) : this.locale.equals(that.locale));
    }
    return false;
  }

  @Override
  public int hashCode() {
    if (!$hashCodeMemoized) {
      int __h = 1;
      __h *= 1000003;
      __h ^= (propertyId == null) ? 0 : propertyId.hashCode();
      __h *= 1000003;
      __h ^= (locale == null) ? 0 : locale.hashCode();
      $hashCode = __h;
      $hashCodeMemoized = true;
    }
    return $hashCode;
  }

  @Override
  public String toString() {
    if ($toString == null) {
      $toString = "PropertyDistrictQuery{"
        + "propertyId=" + propertyId + ", "
        + "locale=" + locale
        + "}";
    }
    return $toString;
  }

  public static Builder builder() {
    return new Builder();
  }

  @Override
  public String id() {
    return OPERATION_ID;
  }

  @Override
  public String document() {
    return OPERATION_DOCUMENT;
  }

  @Override
  public String name() {
    return OPERATION_NAME;
  }

  @Override
  public void serializeVariables(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
      boolean withDefaultValues) throws IOException {
    PropertyDistrictQuery_VariablesAdapter.INSTANCE.serializeVariables(writer, this, customScalarAdapters, withDefaultValues);
  }

  @Override
  public Adapter<Data> adapter() {
    return new ObjectAdapter<Data>(PropertyDistrictQuery_ResponseAdapter.Data.INSTANCE, false);
  }

  @Override
  public CompiledField rootField() {
    return new CompiledField.Builder(
      "data",
      com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.Query.type
    )
    .selections(PropertyDistrictQuerySelections.__root)
    .build();
  }

  public static final class Builder {
    private String propertyId;

    private Optional<String> locale = Optional.empty();

    Builder() {
    }

    public Builder propertyId(String propertyId) {
      this.propertyId = propertyId;
      return this;
    }

    public Builder locale(String locale) {
      this.locale = Optional.of(locale);
      return this;
    }

    public PropertyDistrictQuery build() {
      return new PropertyDistrictQuery(propertyId, locale);
    }
  }

  public static class Data implements Query.Data {
    public Optional<Property> property;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public Data(Optional<Property> property) {
      this.property = property;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Data) {
        Data that = (Data) o;
        return ((this.property == null) ? (that.property == null) : this.property.equals(that.property));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (property == null) ? 0 : property.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Data{"
          + "property=" + property
          + "}";
      }
      return $toString;
    }
  }

  public static class Property {
    /**
     * Jurisdiction regulatory requirements/parameters that apply to this property's rental conditions.
     */
    public Optional<District> district;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public Property(Optional<District> district) {
      this.district = district;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Property) {
        Property that = (Property) o;
        return ((this.district == null) ? (that.district == null) : this.district.equals(that.district));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (district == null) ? 0 : district.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Property{"
          + "district=" + district
          + "}";
      }
      return $toString;
    }
  }

  public static class District {
    /**
     * Description of the district regulation.
     */
    public Optional<String> description;

    /**
     * District ID (such as Miami Beach).
     */
    public String id;

    /**
     * List of legal property types.
     */
    public List<Optional<LegalPropertyType>> legalPropertyTypes;

    /**
     * Localized district name that can be used for display.
     */
    public Optional<String> localizedName;

    /**
     * Four-character locale code (language and country codes) of property's local district (such as ja-JP for a property in Japan).
     */
    public Optional<String> nativeLocale;

    /**
     * URL to jurisdiction regulation information.
     */
    public Optional<List<Optional<String>>> referenceUrls;

    /**
     * Whether registration is required by the jurisdiction.
     */
    public Boolean registrationRequired;

    /**
     * Jurisdiction regulations that the partner needs to meet to comply with onboarding.
     */
    public Optional<List<Optional<Requirement>>> requirements;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public District(Optional<String> description, String id,
        List<Optional<LegalPropertyType>> legalPropertyTypes, Optional<String> localizedName,
        Optional<String> nativeLocale, Optional<List<Optional<String>>> referenceUrls,
        Boolean registrationRequired, Optional<List<Optional<Requirement>>> requirements) {
      this.description = description;
      this.id = id;
      this.legalPropertyTypes = legalPropertyTypes;
      this.localizedName = localizedName;
      this.nativeLocale = nativeLocale;
      this.referenceUrls = referenceUrls;
      this.registrationRequired = registrationRequired;
      this.requirements = requirements;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof District) {
        District that = (District) o;
        return ((this.description == null) ? (that.description == null) : this.description.equals(that.description))
         &&((this.id == null) ? (that.id == null) : this.id.equals(that.id))
         &&((this.legalPropertyTypes == null) ? (that.legalPropertyTypes == null) : this.legalPropertyTypes.equals(that.legalPropertyTypes))
         &&((this.localizedName == null) ? (that.localizedName == null) : this.localizedName.equals(that.localizedName))
         &&((this.nativeLocale == null) ? (that.nativeLocale == null) : this.nativeLocale.equals(that.nativeLocale))
         &&((this.referenceUrls == null) ? (that.referenceUrls == null) : this.referenceUrls.equals(that.referenceUrls))
         &&((this.registrationRequired == null) ? (that.registrationRequired == null) : this.registrationRequired.equals(that.registrationRequired))
         &&((this.requirements == null) ? (that.requirements == null) : this.requirements.equals(that.requirements));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (description == null) ? 0 : description.hashCode();
        __h *= 1000003;
        __h ^= (id == null) ? 0 : id.hashCode();
        __h *= 1000003;
        __h ^= (legalPropertyTypes == null) ? 0 : legalPropertyTypes.hashCode();
        __h *= 1000003;
        __h ^= (localizedName == null) ? 0 : localizedName.hashCode();
        __h *= 1000003;
        __h ^= (nativeLocale == null) ? 0 : nativeLocale.hashCode();
        __h *= 1000003;
        __h ^= (referenceUrls == null) ? 0 : referenceUrls.hashCode();
        __h *= 1000003;
        __h ^= (registrationRequired == null) ? 0 : registrationRequired.hashCode();
        __h *= 1000003;
        __h ^= (requirements == null) ? 0 : requirements.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "District{"
          + "description=" + description + ", "
          + "id=" + id + ", "
          + "legalPropertyTypes=" + legalPropertyTypes + ", "
          + "localizedName=" + localizedName + ", "
          + "nativeLocale=" + nativeLocale + ", "
          + "referenceUrls=" + referenceUrls + ", "
          + "registrationRequired=" + registrationRequired + ", "
          + "requirements=" + requirements
          + "}";
      }
      return $toString;
    }
  }

  public static class LegalPropertyType {
    /**
     * Legal property subtype, applicable for residences, such as primary home or secondary home.
     */
    public Optional<String> subtype;

    /**
     * Legal property type, such as hotel, bed and breakfast, residence, etc.
     */
    public Optional<String> type;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public LegalPropertyType(Optional<String> subtype, Optional<String> type) {
      this.subtype = subtype;
      this.type = type;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof LegalPropertyType) {
        LegalPropertyType that = (LegalPropertyType) o;
        return ((this.subtype == null) ? (that.subtype == null) : this.subtype.equals(that.subtype))
         &&((this.type == null) ? (that.type == null) : this.type.equals(that.type));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (subtype == null) ? 0 : subtype.hashCode();
        __h *= 1000003;
        __h ^= (type == null) ? 0 : type.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "LegalPropertyType{"
          + "subtype=" + subtype + ", "
          + "type=" + type
          + "}";
      }
      return $toString;
    }
  }

  public static class Requirement {
    /**
     * Additional required regulation data by jurisdiction, such as license holder name or property address.
     */
    public Optional<List<Optional<AdditionalDataRequirement>>> additionalDataRequirements;

    /**
     * Exemptions of a requirement under certain conditions.
     */
    public Optional<List<Optional<Exemption>>> exemptions;

    /**
     * Whether this regulatory category is a vacation rental.
     */
    public Optional<Boolean> isVacationRental;

    /**
     * Maximum number of nights allowed by the jurisdiction. null means no requirement.
     */
    public Optional<MaxNightCap> maxNightCap;

    /**
     * Minimum number of stay nights for this category (default is 1).
     */
    public Integer minStayNights;

    /**
     * Regulation requirement that EG supports.
     */
    public Optional<List<Optional<QualifiedPropertyType>>> qualifiedPropertyTypes;

    /**
     * List of registration number requirements.
     */
    public Optional<List<RegistrationNumberRequirement>> registrationNumberRequirements;

    /**
     * Property regulatory category where the registration number requirements apply.
     */
    public Optional<RegulatoryCategory> regulatoryCategory;

    /**
     * Localized string of the regulatory category.
     */
    public Optional<String> regulatoryCategoryLabel;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public Requirement(
        Optional<List<Optional<AdditionalDataRequirement>>> additionalDataRequirements,
        Optional<List<Optional<Exemption>>> exemptions, Optional<Boolean> isVacationRental,
        Optional<MaxNightCap> maxNightCap, Integer minStayNights,
        Optional<List<Optional<QualifiedPropertyType>>> qualifiedPropertyTypes,
        Optional<List<RegistrationNumberRequirement>> registrationNumberRequirements,
        Optional<RegulatoryCategory> regulatoryCategory, Optional<String> regulatoryCategoryLabel) {
      this.additionalDataRequirements = additionalDataRequirements;
      this.exemptions = exemptions;
      this.isVacationRental = isVacationRental;
      this.maxNightCap = maxNightCap;
      this.minStayNights = minStayNights;
      this.qualifiedPropertyTypes = qualifiedPropertyTypes;
      this.registrationNumberRequirements = registrationNumberRequirements;
      this.regulatoryCategory = regulatoryCategory;
      this.regulatoryCategoryLabel = regulatoryCategoryLabel;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Requirement) {
        Requirement that = (Requirement) o;
        return ((this.additionalDataRequirements == null) ? (that.additionalDataRequirements == null) : this.additionalDataRequirements.equals(that.additionalDataRequirements))
         &&((this.exemptions == null) ? (that.exemptions == null) : this.exemptions.equals(that.exemptions))
         &&((this.isVacationRental == null) ? (that.isVacationRental == null) : this.isVacationRental.equals(that.isVacationRental))
         &&((this.maxNightCap == null) ? (that.maxNightCap == null) : this.maxNightCap.equals(that.maxNightCap))
         &&((this.minStayNights == null) ? (that.minStayNights == null) : this.minStayNights.equals(that.minStayNights))
         &&((this.qualifiedPropertyTypes == null) ? (that.qualifiedPropertyTypes == null) : this.qualifiedPropertyTypes.equals(that.qualifiedPropertyTypes))
         &&((this.registrationNumberRequirements == null) ? (that.registrationNumberRequirements == null) : this.registrationNumberRequirements.equals(that.registrationNumberRequirements))
         &&((this.regulatoryCategory == null) ? (that.regulatoryCategory == null) : this.regulatoryCategory.equals(that.regulatoryCategory))
         &&((this.regulatoryCategoryLabel == null) ? (that.regulatoryCategoryLabel == null) : this.regulatoryCategoryLabel.equals(that.regulatoryCategoryLabel));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (additionalDataRequirements == null) ? 0 : additionalDataRequirements.hashCode();
        __h *= 1000003;
        __h ^= (exemptions == null) ? 0 : exemptions.hashCode();
        __h *= 1000003;
        __h ^= (isVacationRental == null) ? 0 : isVacationRental.hashCode();
        __h *= 1000003;
        __h ^= (maxNightCap == null) ? 0 : maxNightCap.hashCode();
        __h *= 1000003;
        __h ^= (minStayNights == null) ? 0 : minStayNights.hashCode();
        __h *= 1000003;
        __h ^= (qualifiedPropertyTypes == null) ? 0 : qualifiedPropertyTypes.hashCode();
        __h *= 1000003;
        __h ^= (registrationNumberRequirements == null) ? 0 : registrationNumberRequirements.hashCode();
        __h *= 1000003;
        __h ^= (regulatoryCategory == null) ? 0 : regulatoryCategory.hashCode();
        __h *= 1000003;
        __h ^= (regulatoryCategoryLabel == null) ? 0 : regulatoryCategoryLabel.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Requirement{"
          + "additionalDataRequirements=" + additionalDataRequirements + ", "
          + "exemptions=" + exemptions + ", "
          + "isVacationRental=" + isVacationRental + ", "
          + "maxNightCap=" + maxNightCap + ", "
          + "minStayNights=" + minStayNights + ", "
          + "qualifiedPropertyTypes=" + qualifiedPropertyTypes + ", "
          + "registrationNumberRequirements=" + registrationNumberRequirements + ", "
          + "regulatoryCategory=" + regulatoryCategory + ", "
          + "regulatoryCategoryLabel=" + regulatoryCategoryLabel
          + "}";
      }
      return $toString;
    }
  }

  public static class AdditionalDataRequirement {
    /**
     * Grouping to which the field belongs, for UI layout purposes.
     */
    public Optional<String> group;

    /**
     * Description of the group, to be localized.
     */
    public Optional<String> groupLocalized;

    /**
     * Whether the data is optional.
     */
    public Optional<String> isOptional;

    /**
     * Field name for the information to be captured.
     */
    public String key;

    /**
     * Description of the key, to be localized.
     */
    public Optional<String> keyLocalized;

    /**
     * Subtype of data.
     */
    public Optional<String> subtype;

    /**
     * Description of subtype, to be localized.
     */
    public Optional<String> subtypeLocalized;

    /**
     * Type of data.
     */
    public Optional<String> type;

    /**
     * Description of type, to be localized.
     */
    public Optional<String> typeLocalized;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public AdditionalDataRequirement(Optional<String> group, Optional<String> groupLocalized,
        Optional<String> isOptional, String key, Optional<String> keyLocalized,
        Optional<String> subtype, Optional<String> subtypeLocalized, Optional<String> type,
        Optional<String> typeLocalized) {
      this.group = group;
      this.groupLocalized = groupLocalized;
      this.isOptional = isOptional;
      this.key = key;
      this.keyLocalized = keyLocalized;
      this.subtype = subtype;
      this.subtypeLocalized = subtypeLocalized;
      this.type = type;
      this.typeLocalized = typeLocalized;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof AdditionalDataRequirement) {
        AdditionalDataRequirement that = (AdditionalDataRequirement) o;
        return ((this.group == null) ? (that.group == null) : this.group.equals(that.group))
         &&((this.groupLocalized == null) ? (that.groupLocalized == null) : this.groupLocalized.equals(that.groupLocalized))
         &&((this.isOptional == null) ? (that.isOptional == null) : this.isOptional.equals(that.isOptional))
         &&((this.key == null) ? (that.key == null) : this.key.equals(that.key))
         &&((this.keyLocalized == null) ? (that.keyLocalized == null) : this.keyLocalized.equals(that.keyLocalized))
         &&((this.subtype == null) ? (that.subtype == null) : this.subtype.equals(that.subtype))
         &&((this.subtypeLocalized == null) ? (that.subtypeLocalized == null) : this.subtypeLocalized.equals(that.subtypeLocalized))
         &&((this.type == null) ? (that.type == null) : this.type.equals(that.type))
         &&((this.typeLocalized == null) ? (that.typeLocalized == null) : this.typeLocalized.equals(that.typeLocalized));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (group == null) ? 0 : group.hashCode();
        __h *= 1000003;
        __h ^= (groupLocalized == null) ? 0 : groupLocalized.hashCode();
        __h *= 1000003;
        __h ^= (isOptional == null) ? 0 : isOptional.hashCode();
        __h *= 1000003;
        __h ^= (key == null) ? 0 : key.hashCode();
        __h *= 1000003;
        __h ^= (keyLocalized == null) ? 0 : keyLocalized.hashCode();
        __h *= 1000003;
        __h ^= (subtype == null) ? 0 : subtype.hashCode();
        __h *= 1000003;
        __h ^= (subtypeLocalized == null) ? 0 : subtypeLocalized.hashCode();
        __h *= 1000003;
        __h ^= (type == null) ? 0 : type.hashCode();
        __h *= 1000003;
        __h ^= (typeLocalized == null) ? 0 : typeLocalized.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "AdditionalDataRequirement{"
          + "group=" + group + ", "
          + "groupLocalized=" + groupLocalized + ", "
          + "isOptional=" + isOptional + ", "
          + "key=" + key + ", "
          + "keyLocalized=" + keyLocalized + ", "
          + "subtype=" + subtype + ", "
          + "subtypeLocalized=" + subtypeLocalized + ", "
          + "type=" + type + ", "
          + "typeLocalized=" + typeLocalized
          + "}";
      }
      return $toString;
    }
  }

  public static class Exemption {
    /**
     * Exemption type.
     */
    public Optional<ExemptionCategory> category;

    /**
     * Description of the exemption.
     */
    public Optional<String> description;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public Exemption(Optional<ExemptionCategory> category, Optional<String> description) {
      this.category = category;
      this.description = description;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof Exemption) {
        Exemption that = (Exemption) o;
        return ((this.category == null) ? (that.category == null) : this.category.equals(that.category))
         &&((this.description == null) ? (that.description == null) : this.description.equals(that.description));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (category == null) ? 0 : category.hashCode();
        __h *= 1000003;
        __h ^= (description == null) ? 0 : description.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "Exemption{"
          + "category=" + category + ", "
          + "description=" + description
          + "}";
      }
      return $toString;
    }
  }

  public static class MaxNightCap {
    /**
     * Annual night cap.
     */
    public Optional<Integer> annualLimit;

    /**
     * Whether the cap is enforced (or just educational).
     */
    public Optional<Boolean> isEnforced;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public MaxNightCap(Optional<Integer> annualLimit, Optional<Boolean> isEnforced) {
      this.annualLimit = annualLimit;
      this.isEnforced = isEnforced;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof MaxNightCap) {
        MaxNightCap that = (MaxNightCap) o;
        return ((this.annualLimit == null) ? (that.annualLimit == null) : this.annualLimit.equals(that.annualLimit))
         &&((this.isEnforced == null) ? (that.isEnforced == null) : this.isEnforced.equals(that.isEnforced));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (annualLimit == null) ? 0 : annualLimit.hashCode();
        __h *= 1000003;
        __h ^= (isEnforced == null) ? 0 : isEnforced.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "MaxNightCap{"
          + "annualLimit=" + annualLimit + ", "
          + "isEnforced=" + isEnforced
          + "}";
      }
      return $toString;
    }
  }

  public static class QualifiedPropertyType {
    /**
     * Legal property subtype, applicable for residences, such as primary home or secondary home.
     */
    public Optional<String> subtype;

    /**
     * Legal property type, such as hotel, bed and breakfast, residence, etc.
     */
    public Optional<String> type;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public QualifiedPropertyType(Optional<String> subtype, Optional<String> type) {
      this.subtype = subtype;
      this.type = type;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof QualifiedPropertyType) {
        QualifiedPropertyType that = (QualifiedPropertyType) o;
        return ((this.subtype == null) ? (that.subtype == null) : this.subtype.equals(that.subtype))
         &&((this.type == null) ? (that.type == null) : this.type.equals(that.type));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (subtype == null) ? 0 : subtype.hashCode();
        __h *= 1000003;
        __h ^= (type == null) ? 0 : type.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "QualifiedPropertyType{"
          + "subtype=" + subtype + ", "
          + "type=" + type
          + "}";
      }
      return $toString;
    }
  }

  public static class RegistrationNumberRequirement {
    /**
     * Whether pending applications are allowed to list.
     */
    public Boolean allowPendingRegistrations;

    /**
     * Sample format string to use as an example for partners.
     */
    public Optional<String> format;

    /**
     * Whether the registration expiration date is required.
     */
    public Boolean isExpirationDateRequired;

    /**
     * Whether the registration number is optional.
     */
    public Boolean isOptional;

    /**
     * Localized display name (such as みんぱく for Japan Minpaku).
     */
    public Optional<String> localName;

    /**
     * Registration number type.
     */
    public Optional<RegistrationNumberType> numberType;

    /**
     * Label of the registration number.
     */
    public Optional<String> numberTypeLabel;

    /**
     * Purpose of this requirement if other besides common regulatory validations.
     */
    public Optional<Purpose> purpose;

    /**
     * Regex used to validate the syntax of the registration number.
     */
    public Optional<String> regex;

    /**
     * Information about external validation parameters, if required for the registration number.
     */
    public Optional<ThirdPartyValidation> thirdPartyValidation;

    /**
     * URL of a page that provides information about the number requirement.
     */
    public Optional<String> url;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public RegistrationNumberRequirement(Boolean allowPendingRegistrations, Optional<String> format,
        Boolean isExpirationDateRequired, Boolean isOptional, Optional<String> localName,
        Optional<RegistrationNumberType> numberType, Optional<String> numberTypeLabel,
        Optional<Purpose> purpose, Optional<String> regex,
        Optional<ThirdPartyValidation> thirdPartyValidation, Optional<String> url) {
      this.allowPendingRegistrations = allowPendingRegistrations;
      this.format = format;
      this.isExpirationDateRequired = isExpirationDateRequired;
      this.isOptional = isOptional;
      this.localName = localName;
      this.numberType = numberType;
      this.numberTypeLabel = numberTypeLabel;
      this.purpose = purpose;
      this.regex = regex;
      this.thirdPartyValidation = thirdPartyValidation;
      this.url = url;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof RegistrationNumberRequirement) {
        RegistrationNumberRequirement that = (RegistrationNumberRequirement) o;
        return ((this.allowPendingRegistrations == null) ? (that.allowPendingRegistrations == null) : this.allowPendingRegistrations.equals(that.allowPendingRegistrations))
         &&((this.format == null) ? (that.format == null) : this.format.equals(that.format))
         &&((this.isExpirationDateRequired == null) ? (that.isExpirationDateRequired == null) : this.isExpirationDateRequired.equals(that.isExpirationDateRequired))
         &&((this.isOptional == null) ? (that.isOptional == null) : this.isOptional.equals(that.isOptional))
         &&((this.localName == null) ? (that.localName == null) : this.localName.equals(that.localName))
         &&((this.numberType == null) ? (that.numberType == null) : this.numberType.equals(that.numberType))
         &&((this.numberTypeLabel == null) ? (that.numberTypeLabel == null) : this.numberTypeLabel.equals(that.numberTypeLabel))
         &&((this.purpose == null) ? (that.purpose == null) : this.purpose.equals(that.purpose))
         &&((this.regex == null) ? (that.regex == null) : this.regex.equals(that.regex))
         &&((this.thirdPartyValidation == null) ? (that.thirdPartyValidation == null) : this.thirdPartyValidation.equals(that.thirdPartyValidation))
         &&((this.url == null) ? (that.url == null) : this.url.equals(that.url));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (allowPendingRegistrations == null) ? 0 : allowPendingRegistrations.hashCode();
        __h *= 1000003;
        __h ^= (format == null) ? 0 : format.hashCode();
        __h *= 1000003;
        __h ^= (isExpirationDateRequired == null) ? 0 : isExpirationDateRequired.hashCode();
        __h *= 1000003;
        __h ^= (isOptional == null) ? 0 : isOptional.hashCode();
        __h *= 1000003;
        __h ^= (localName == null) ? 0 : localName.hashCode();
        __h *= 1000003;
        __h ^= (numberType == null) ? 0 : numberType.hashCode();
        __h *= 1000003;
        __h ^= (numberTypeLabel == null) ? 0 : numberTypeLabel.hashCode();
        __h *= 1000003;
        __h ^= (purpose == null) ? 0 : purpose.hashCode();
        __h *= 1000003;
        __h ^= (regex == null) ? 0 : regex.hashCode();
        __h *= 1000003;
        __h ^= (thirdPartyValidation == null) ? 0 : thirdPartyValidation.hashCode();
        __h *= 1000003;
        __h ^= (url == null) ? 0 : url.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "RegistrationNumberRequirement{"
          + "allowPendingRegistrations=" + allowPendingRegistrations + ", "
          + "format=" + format + ", "
          + "isExpirationDateRequired=" + isExpirationDateRequired + ", "
          + "isOptional=" + isOptional + ", "
          + "localName=" + localName + ", "
          + "numberType=" + numberType + ", "
          + "numberTypeLabel=" + numberTypeLabel + ", "
          + "purpose=" + purpose + ", "
          + "regex=" + regex + ", "
          + "thirdPartyValidation=" + thirdPartyValidation + ", "
          + "url=" + url
          + "}";
      }
      return $toString;
    }
  }

  public static class ThirdPartyValidation {
    /**
     * Attributes used to validate the registration number as provided by the third-party.
     */
    public Optional<List<Optional<String>>> attributes;

    /**
     * Whether third-party validation is required.
     */
    public Boolean required;

    private transient volatile int $hashCode;

    private transient volatile boolean $hashCodeMemoized;

    private transient volatile String $toString;

    public ThirdPartyValidation(Optional<List<Optional<String>>> attributes, Boolean required) {
      this.attributes = attributes;
      this.required = required;
    }

    @Override
    public boolean equals(Object o) {
      if (o == this) {
        return true;
      }
      if (o instanceof ThirdPartyValidation) {
        ThirdPartyValidation that = (ThirdPartyValidation) o;
        return ((this.attributes == null) ? (that.attributes == null) : this.attributes.equals(that.attributes))
         &&((this.required == null) ? (that.required == null) : this.required.equals(that.required));
      }
      return false;
    }

    @Override
    public int hashCode() {
      if (!$hashCodeMemoized) {
        int __h = 1;
        __h *= 1000003;
        __h ^= (attributes == null) ? 0 : attributes.hashCode();
        __h *= 1000003;
        __h ^= (required == null) ? 0 : required.hashCode();
        $hashCode = __h;
        $hashCodeMemoized = true;
      }
      return $hashCode;
    }

    @Override
    public String toString() {
      if ($toString == null) {
        $toString = "ThirdPartyValidation{"
          + "attributes=" + attributes + ", "
          + "required=" + required
          + "}";
      }
      return $toString;
    }
  }
}
