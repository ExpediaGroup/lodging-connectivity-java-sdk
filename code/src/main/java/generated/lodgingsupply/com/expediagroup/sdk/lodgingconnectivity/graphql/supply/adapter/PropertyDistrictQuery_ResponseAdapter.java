//
// AUTO-GENERATED FILE. DO NOT MODIFY.
//
// This class was automatically generated by Apollo GraphQL version '4.0.0'.
//
package com.expediagroup.sdk.lodgingconnectivity.graphql.supply.adapter;

import com.apollographql.apollo.api.Adapter;
import com.apollographql.apollo.api.Adapters;
import com.apollographql.apollo.api.Assertions;
import com.apollographql.apollo.api.CustomScalarAdapters;
import com.apollographql.apollo.api.ListAdapter;
import com.apollographql.apollo.api.ObjectAdapter;
import com.apollographql.apollo.api.json.JsonReader;
import com.apollographql.apollo.api.json.JsonWriter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.PropertyDistrictQuery;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.ExemptionCategory;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.Purpose;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.RegistrationNumberType;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.RegulatoryCategory;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.ExemptionCategory_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.OptionalAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.OptionalAdapters;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.Purpose_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.RegistrationNumberType_ResponseAdapter;
import com.expediagroup.sdk.lodgingconnectivity.graphql.supply.type.adapter.RegulatoryCategory_ResponseAdapter;
import java.io.IOException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Override;
import java.lang.String;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class PropertyDistrictQuery_ResponseAdapter {
  public enum Data implements Adapter<PropertyDistrictQuery.Data> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("property");

    @Override
    public PropertyDistrictQuery.Data fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<PropertyDistrictQuery.Property> _property = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _property = new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.Property>(Property.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new PropertyDistrictQuery.Data(
        _property
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.Data value) throws IOException {
      writer.name("property");
      new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.Property>(Property.INSTANCE, false)).toJson(writer, customScalarAdapters, value.property);
    }
  }

  public enum Property implements Adapter<PropertyDistrictQuery.Property> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("district");

    @Override
    public PropertyDistrictQuery.Property fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<PropertyDistrictQuery.District> _district = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _district = new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.District>(District.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new PropertyDistrictQuery.Property(
        _district
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.Property value) throws IOException {
      writer.name("district");
      new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.District>(District.INSTANCE, false)).toJson(writer, customScalarAdapters, value.district);
    }
  }

  public enum District implements Adapter<PropertyDistrictQuery.District> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("description", "id", "legalPropertyTypes", "localizedName", "nativeLocale", "referenceUrls", "registrationRequired", "requirements");

    @Override
    public PropertyDistrictQuery.District fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<String> _description = null;
      String _id = null;
      List<Optional<PropertyDistrictQuery.LegalPropertyType>> _legalPropertyTypes = null;
      Optional<String> _localizedName = null;
      Optional<String> _nativeLocale = null;
      Optional<List<Optional<String>>> _referenceUrls = null;
      Boolean _registrationRequired = null;
      Optional<List<Optional<PropertyDistrictQuery.Requirement>>> _requirements = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _description = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _id = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 2: _legalPropertyTypes = new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.LegalPropertyType>(LegalPropertyType.INSTANCE, false))).fromJson(reader, customScalarAdapters); break;
          case 3: _localizedName = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 4: _nativeLocale = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 5: _referenceUrls = new OptionalAdapter<>(new ListAdapter<>(OptionalAdapters.OptionalStringAdapter)).fromJson(reader, customScalarAdapters); break;
          case 6: _registrationRequired = Adapters.BooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 7: _requirements = new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.Requirement>(Requirement.INSTANCE, false)))).fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_id, "id");
      Assertions.checkFieldNotMissing(_legalPropertyTypes, "legalPropertyTypes");
      Assertions.checkFieldNotMissing(_registrationRequired, "registrationRequired");

      return new PropertyDistrictQuery.District(
        _description,
        _id,
        _legalPropertyTypes,
        _localizedName,
        _nativeLocale,
        _referenceUrls,
        _registrationRequired,
        _requirements
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.District value) throws IOException {
      writer.name("description");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.description);

      writer.name("id");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.id);

      writer.name("legalPropertyTypes");
      new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.LegalPropertyType>(LegalPropertyType.INSTANCE, false))).toJson(writer, customScalarAdapters, value.legalPropertyTypes);

      writer.name("localizedName");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.localizedName);

      writer.name("nativeLocale");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.nativeLocale);

      writer.name("referenceUrls");
      new OptionalAdapter<>(new ListAdapter<>(OptionalAdapters.OptionalStringAdapter)).toJson(writer, customScalarAdapters, value.referenceUrls);

      writer.name("registrationRequired");
      Adapters.BooleanAdapter.toJson(writer, customScalarAdapters, value.registrationRequired);

      writer.name("requirements");
      new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.Requirement>(Requirement.INSTANCE, false)))).toJson(writer, customScalarAdapters, value.requirements);
    }
  }

  public enum LegalPropertyType implements Adapter<PropertyDistrictQuery.LegalPropertyType> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("subtype", "type");

    @Override
    public PropertyDistrictQuery.LegalPropertyType fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<String> _subtype = null;
      Optional<String> _type = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _subtype = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _type = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new PropertyDistrictQuery.LegalPropertyType(
        _subtype,
        _type
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.LegalPropertyType value) throws IOException {
      writer.name("subtype");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.subtype);

      writer.name("type");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.type);
    }
  }

  public enum Requirement implements Adapter<PropertyDistrictQuery.Requirement> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("additionalDataRequirements", "exemptions", "isVacationRental", "maxNightCap", "minStayNights", "qualifiedPropertyTypes", "registrationNumberRequirements", "regulatoryCategory", "regulatoryCategoryLabel");

    @Override
    public PropertyDistrictQuery.Requirement fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<List<Optional<PropertyDistrictQuery.AdditionalDataRequirement>>> _additionalDataRequirements = null;
      Optional<List<Optional<PropertyDistrictQuery.Exemption>>> _exemptions = null;
      Optional<Boolean> _isVacationRental = null;
      Optional<PropertyDistrictQuery.MaxNightCap> _maxNightCap = null;
      Integer _minStayNights = null;
      Optional<List<Optional<PropertyDistrictQuery.QualifiedPropertyType>>> _qualifiedPropertyTypes = null;
      Optional<List<PropertyDistrictQuery.RegistrationNumberRequirement>> _registrationNumberRequirements = null;
      Optional<RegulatoryCategory> _regulatoryCategory = null;
      Optional<String> _regulatoryCategoryLabel = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _additionalDataRequirements = new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.AdditionalDataRequirement>(AdditionalDataRequirement.INSTANCE, false)))).fromJson(reader, customScalarAdapters); break;
          case 1: _exemptions = new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.Exemption>(Exemption.INSTANCE, false)))).fromJson(reader, customScalarAdapters); break;
          case 2: _isVacationRental = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _maxNightCap = new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.MaxNightCap>(MaxNightCap.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 4: _minStayNights = Adapters.IntAdapter.fromJson(reader, customScalarAdapters); break;
          case 5: _qualifiedPropertyTypes = new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.QualifiedPropertyType>(QualifiedPropertyType.INSTANCE, false)))).fromJson(reader, customScalarAdapters); break;
          case 6: _registrationNumberRequirements = new OptionalAdapter<>(new ListAdapter<>(new ObjectAdapter<PropertyDistrictQuery.RegistrationNumberRequirement>(RegistrationNumberRequirement.INSTANCE, false))).fromJson(reader, customScalarAdapters); break;
          case 7: _regulatoryCategory = new OptionalAdapter<>(RegulatoryCategory_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 8: _regulatoryCategoryLabel = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_minStayNights, "minStayNights");

      return new PropertyDistrictQuery.Requirement(
        _additionalDataRequirements,
        _exemptions,
        _isVacationRental,
        _maxNightCap,
        _minStayNights,
        _qualifiedPropertyTypes,
        _registrationNumberRequirements,
        _regulatoryCategory,
        _regulatoryCategoryLabel
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.Requirement value) throws IOException {
      writer.name("additionalDataRequirements");
      new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.AdditionalDataRequirement>(AdditionalDataRequirement.INSTANCE, false)))).toJson(writer, customScalarAdapters, value.additionalDataRequirements);

      writer.name("exemptions");
      new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.Exemption>(Exemption.INSTANCE, false)))).toJson(writer, customScalarAdapters, value.exemptions);

      writer.name("isVacationRental");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.isVacationRental);

      writer.name("maxNightCap");
      new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.MaxNightCap>(MaxNightCap.INSTANCE, false)).toJson(writer, customScalarAdapters, value.maxNightCap);

      writer.name("minStayNights");
      Adapters.IntAdapter.toJson(writer, customScalarAdapters, value.minStayNights);

      writer.name("qualifiedPropertyTypes");
      new OptionalAdapter<>(new ListAdapter<>(new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.QualifiedPropertyType>(QualifiedPropertyType.INSTANCE, false)))).toJson(writer, customScalarAdapters, value.qualifiedPropertyTypes);

      writer.name("registrationNumberRequirements");
      new OptionalAdapter<>(new ListAdapter<>(new ObjectAdapter<PropertyDistrictQuery.RegistrationNumberRequirement>(RegistrationNumberRequirement.INSTANCE, false))).toJson(writer, customScalarAdapters, value.registrationNumberRequirements);

      writer.name("regulatoryCategory");
      new OptionalAdapter<>(RegulatoryCategory_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.regulatoryCategory);

      writer.name("regulatoryCategoryLabel");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.regulatoryCategoryLabel);
    }
  }

  public enum AdditionalDataRequirement implements Adapter<PropertyDistrictQuery.AdditionalDataRequirement> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("group", "groupLocalized", "isOptional", "key", "keyLocalized", "subtype", "subtypeLocalized", "type", "typeLocalized");

    @Override
    public PropertyDistrictQuery.AdditionalDataRequirement fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<String> _group = null;
      Optional<String> _groupLocalized = null;
      Optional<String> _isOptional = null;
      String _key = null;
      Optional<String> _keyLocalized = null;
      Optional<String> _subtype = null;
      Optional<String> _subtypeLocalized = null;
      Optional<String> _type = null;
      Optional<String> _typeLocalized = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _group = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _groupLocalized = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 2: _isOptional = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _key = Adapters.StringAdapter.fromJson(reader, customScalarAdapters); break;
          case 4: _keyLocalized = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 5: _subtype = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 6: _subtypeLocalized = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 7: _type = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 8: _typeLocalized = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_key, "key");

      return new PropertyDistrictQuery.AdditionalDataRequirement(
        _group,
        _groupLocalized,
        _isOptional,
        _key,
        _keyLocalized,
        _subtype,
        _subtypeLocalized,
        _type,
        _typeLocalized
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.AdditionalDataRequirement value) throws IOException {
      writer.name("group");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.group);

      writer.name("groupLocalized");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.groupLocalized);

      writer.name("isOptional");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.isOptional);

      writer.name("key");
      Adapters.StringAdapter.toJson(writer, customScalarAdapters, value.key);

      writer.name("keyLocalized");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.keyLocalized);

      writer.name("subtype");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.subtype);

      writer.name("subtypeLocalized");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.subtypeLocalized);

      writer.name("type");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.type);

      writer.name("typeLocalized");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.typeLocalized);
    }
  }

  public enum Exemption implements Adapter<PropertyDistrictQuery.Exemption> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("category", "description");

    @Override
    public PropertyDistrictQuery.Exemption fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<ExemptionCategory> _category = null;
      Optional<String> _description = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _category = new OptionalAdapter<>(ExemptionCategory_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 1: _description = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new PropertyDistrictQuery.Exemption(
        _category,
        _description
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.Exemption value) throws IOException {
      writer.name("category");
      new OptionalAdapter<>(ExemptionCategory_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.category);

      writer.name("description");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.description);
    }
  }

  public enum MaxNightCap implements Adapter<PropertyDistrictQuery.MaxNightCap> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("annualLimit", "isEnforced");

    @Override
    public PropertyDistrictQuery.MaxNightCap fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<Integer> _annualLimit = null;
      Optional<Boolean> _isEnforced = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _annualLimit = OptionalAdapters.OptionalIntAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _isEnforced = OptionalAdapters.OptionalBooleanAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new PropertyDistrictQuery.MaxNightCap(
        _annualLimit,
        _isEnforced
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.MaxNightCap value) throws IOException {
      writer.name("annualLimit");
      OptionalAdapters.OptionalIntAdapter.toJson(writer, customScalarAdapters, value.annualLimit);

      writer.name("isEnforced");
      OptionalAdapters.OptionalBooleanAdapter.toJson(writer, customScalarAdapters, value.isEnforced);
    }
  }

  public enum QualifiedPropertyType implements Adapter<PropertyDistrictQuery.QualifiedPropertyType> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("subtype", "type");

    @Override
    public PropertyDistrictQuery.QualifiedPropertyType fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<String> _subtype = null;
      Optional<String> _type = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _subtype = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _type = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      return new PropertyDistrictQuery.QualifiedPropertyType(
        _subtype,
        _type
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.QualifiedPropertyType value) throws IOException {
      writer.name("subtype");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.subtype);

      writer.name("type");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.type);
    }
  }

  public enum RegistrationNumberRequirement implements Adapter<PropertyDistrictQuery.RegistrationNumberRequirement> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("allowPendingRegistrations", "format", "isExpirationDateRequired", "isOptional", "localName", "numberType", "numberTypeLabel", "purpose", "regex", "thirdPartyValidation", "url");

    @Override
    public PropertyDistrictQuery.RegistrationNumberRequirement fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Boolean _allowPendingRegistrations = null;
      Optional<String> _format = null;
      Boolean _isExpirationDateRequired = null;
      Boolean _isOptional = null;
      Optional<String> _localName = null;
      Optional<RegistrationNumberType> _numberType = null;
      Optional<String> _numberTypeLabel = null;
      Optional<Purpose> _purpose = null;
      Optional<String> _regex = null;
      Optional<PropertyDistrictQuery.ThirdPartyValidation> _thirdPartyValidation = null;
      Optional<String> _url = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _allowPendingRegistrations = Adapters.BooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 1: _format = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 2: _isExpirationDateRequired = Adapters.BooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 3: _isOptional = Adapters.BooleanAdapter.fromJson(reader, customScalarAdapters); break;
          case 4: _localName = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 5: _numberType = new OptionalAdapter<>(RegistrationNumberType_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 6: _numberTypeLabel = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 7: _purpose = new OptionalAdapter<>(Purpose_ResponseAdapter.INSTANCE).fromJson(reader, customScalarAdapters); break;
          case 8: _regex = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          case 9: _thirdPartyValidation = new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.ThirdPartyValidation>(ThirdPartyValidation.INSTANCE, false)).fromJson(reader, customScalarAdapters); break;
          case 10: _url = OptionalAdapters.OptionalStringAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_allowPendingRegistrations, "allowPendingRegistrations");
      Assertions.checkFieldNotMissing(_isExpirationDateRequired, "isExpirationDateRequired");
      Assertions.checkFieldNotMissing(_isOptional, "isOptional");

      return new PropertyDistrictQuery.RegistrationNumberRequirement(
        _allowPendingRegistrations,
        _format,
        _isExpirationDateRequired,
        _isOptional,
        _localName,
        _numberType,
        _numberTypeLabel,
        _purpose,
        _regex,
        _thirdPartyValidation,
        _url
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.RegistrationNumberRequirement value) throws IOException {
      writer.name("allowPendingRegistrations");
      Adapters.BooleanAdapter.toJson(writer, customScalarAdapters, value.allowPendingRegistrations);

      writer.name("format");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.format);

      writer.name("isExpirationDateRequired");
      Adapters.BooleanAdapter.toJson(writer, customScalarAdapters, value.isExpirationDateRequired);

      writer.name("isOptional");
      Adapters.BooleanAdapter.toJson(writer, customScalarAdapters, value.isOptional);

      writer.name("localName");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.localName);

      writer.name("numberType");
      new OptionalAdapter<>(RegistrationNumberType_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.numberType);

      writer.name("numberTypeLabel");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.numberTypeLabel);

      writer.name("purpose");
      new OptionalAdapter<>(Purpose_ResponseAdapter.INSTANCE).toJson(writer, customScalarAdapters, value.purpose);

      writer.name("regex");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.regex);

      writer.name("thirdPartyValidation");
      new OptionalAdapter<>(new ObjectAdapter<PropertyDistrictQuery.ThirdPartyValidation>(ThirdPartyValidation.INSTANCE, false)).toJson(writer, customScalarAdapters, value.thirdPartyValidation);

      writer.name("url");
      OptionalAdapters.OptionalStringAdapter.toJson(writer, customScalarAdapters, value.url);
    }
  }

  public enum ThirdPartyValidation implements Adapter<PropertyDistrictQuery.ThirdPartyValidation> {
    INSTANCE;

    private static final List<String> RESPONSE_NAMES = Arrays.asList("attributes", "required");

    @Override
    public PropertyDistrictQuery.ThirdPartyValidation fromJson(JsonReader reader,
        CustomScalarAdapters customScalarAdapters) throws IOException {
      Optional<List<Optional<String>>> _attributes = null;
      Boolean _required = null;

      loop:
      while(true) {
        switch (reader.selectName(RESPONSE_NAMES)) {
          case 0: _attributes = new OptionalAdapter<>(new ListAdapter<>(OptionalAdapters.OptionalStringAdapter)).fromJson(reader, customScalarAdapters); break;
          case 1: _required = Adapters.BooleanAdapter.fromJson(reader, customScalarAdapters); break;
          default: break loop;
        }
      }

      Assertions.checkFieldNotMissing(_required, "required");

      return new PropertyDistrictQuery.ThirdPartyValidation(
        _attributes,
        _required
      );
    }

    @Override
    public void toJson(JsonWriter writer, CustomScalarAdapters customScalarAdapters,
        PropertyDistrictQuery.ThirdPartyValidation value) throws IOException {
      writer.name("attributes");
      new OptionalAdapter<>(new ListAdapter<>(OptionalAdapters.OptionalStringAdapter)).toJson(writer, customScalarAdapters, value.attributes);

      writer.name("required");
      Adapters.BooleanAdapter.toJson(writer, customScalarAdapters, value.required);
    }
  }
}
